require('dotenv').config();
const express = require('express');
const cors = require('cors');
const fetch = require('node-fetch');
const http = require('http');
const CoinStorage = require('./coin-storage');
const priceEngine = require('./services/priceEngine');
const WebSocketServer = require('./services/websocketServer');
const JupiterLivePriceService = require('./jupiterLivePriceService');
const dexscreenerService = require('./dexscreenerService');
const dexpaprikaService = require('./dexpaprikaService');
const heliusService = require('./heliusService');
const rugcheckService = require('./rugcheckService');
const RugcheckAutoProcessor = require('./rugcheckAutoProcessor');
const JupiterTokenService = require('./jupiterTokenService');
const JupiterDataService = require('./jupiterDataService');
const TokenMetadataService = require('./tokenMetadataService');

const app = express();
const PORT = process.env.PORT || 3001;
const coinStorage = new CoinStorage();

// Middleware
app.use(cors({
  origin: [
    'http://localhost:5173', 
    'http://localhost:5174', 
    'http://localhost:5175',  // Added for current frontend port
    'http://localhost:3000',
    'https://moonfeed.app',
    'https://www.moonfeed.app',
    'https://api.moonfeed.app'
  ],
  credentials: true
}));
app.use(express.json());
app.use(express.json());

// Solana Tracker API Configuration
const SOLANA_TRACKER_API_KEY = process.env.SOLANA_TRACKER_API_KEY;
const SOLANA_TRACKER_BASE_URL = 'https://data.solanatracker.io';

// Current serving cache (from latest batch)
let currentCoins = [];

// New tab cache - refreshes every 30 minutes
let newTabCoins = [];
let newTabLastFetch = null;
const NEW_TAB_REFRESH_INTERVAL = 30 * 60 * 1000; // 30 minutes

// Initialize Rugcheck auto-processor
const rugcheckAutoProcessor = new RugcheckAutoProcessor();

// Initialize Jupiter Token Service
const jupiterTokenService = new JupiterTokenService();

// Initialize Jupiter Live Price Service
const jupiterLivePriceService = new JupiterLivePriceService();

// Make Jupiter Live Price Service globally available for WebSocket integration
global.jupiterLivePriceService = jupiterLivePriceService;

// Initialize Jupiter Data Service for market data
const jupiterDataService = new JupiterDataService();

// Initialize Token Metadata Service for metadata enrichment
const tokenMetadataService = new TokenMetadataService();

// Initialize with latest batch
function initializeWithLatestBatch() {
  const latestBatch = coinStorage.getLatestBatch();
  if (latestBatch.length > 0) {
    currentCoins = latestBatch;
    
    // Make coins available to price engine
    global.coinsCache = currentCoins;
    
    // Update Jupiter Live Price Service with new coin list
    if (jupiterLivePriceService && jupiterLivePriceService.isRunning) {
      jupiterLivePriceService.updateCoinList(currentCoins);
    }
    
    console.log(`üöÄ Initialized with latest batch: ${latestBatch.length} coins`);
    
    // Start auto-processor for the loaded batch
    startRugcheckAutoProcessor();
  } else {
    console.log('üì≠ No saved batches found, using sample data');
    // Sample data as fallback
    currentCoins = [
      {
        mintAddress: "7GCihgDB8fe6KNjn2MYtkzZcRjQy3t9GHdC8uHYmW2hr",
        name: "dogwifhat",
        symbol: "WIF",
        image: "https://pump.fun/_next/image?url=https%3A%2F%2Fipfs.io%2Fipfs%2FQmW8GFq&w=256&q=75",
        profileImage: "https://pump.fun/_next/image?url=https%3A%2F%2Fipfs.io%2Fipfs%2FQmW8GFq&w=256&q=75",
        logo: "https://pump.fun/_next/image?url=https%3A%2F%2Fipfs.io%2Fipfs%2FQmW8GFq&w=256&q=75",
        banner: dexscreenerService.generatePlaceholderBanner({ symbol: "WIF" }),
        price_usd: 0.00245,
        market_cap_usd: 2450000,
        volume_24h_usd: 1240000,
        liquidity_usd: 125000,
        description: "dogwifhat - the dog with a hat that everyone loves",
        socialLinks: {},
        socials: {}
      },
      {
        mintAddress: "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263",
        name: "Bonk",
        symbol: "BONK", 
        image: "https://arweave.net/hQiPZOsRZXGXBJd_82PhVdlM_hACsT_q6wqwf5cSY7I",
        profileImage: "https://arweave.net/hQiPZOsRZXGXBJd_82PhVdlM_hACsT_q6wqwf5cSY7I",
        logo: "https://arweave.net/hQiPZOsRZXGXBJd_82PhVdlM_hACsT_q6wqwf5cSY7I",
        banner: dexscreenerService.generatePlaceholderBanner({ symbol: "BONK" }),
        price_usd: 0.0000189,
        market_cap_usd: 1890000,
        volume_24h_usd: 890000,
        liquidity_usd: 95000,
        description: "BONK - the community coin that bonks back",
        socialLinks: {},
        socials: {}
      }
    ];
    
    // Make coins available to price engine
    global.coinsCache = currentCoins;
  }
}

// Make Solana Tracker API request
async function makeSolanaTrackerRequest(endpoint, params = {}) {
  if (!SOLANA_TRACKER_API_KEY) {
    throw new Error('SOLANA_TRACKER_API_KEY not configured');
  }

  const url = new URL(endpoint, SOLANA_TRACKER_BASE_URL);
  Object.keys(params).forEach(key => {
    if (params[key] !== undefined && params[key] !== null) {
      url.searchParams.append(key, params[key]);
    }
  });

  console.log('üîó Solana Tracker API call:', url.toString().replace(SOLANA_TRACKER_API_KEY, '[HIDDEN]'));

  const response = await fetch(url, {
    method: 'GET',
    headers: {
      'x-api-key': SOLANA_TRACKER_API_KEY,
      'Content-Type': 'application/json'
    }
  });

  if (!response.ok) {
    throw new Error(`Solana Tracker API error: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();
  console.log(`‚úÖ Solana Tracker response: ${data.status}, ${data.data?.length || 0} tokens`);
  
  return data;
}

// Fetch ALL coins from Solana Tracker (no limit)
async function fetchFreshCoinBatch() {
  const searchParams = {
    minLiquidity: 50000,        // $50k minimum liquidity
    maxLiquidity: 500000,       // $500k maximum liquidity  
    minVolume: 50000,           // $50k minimum volume
    maxVolume: 5000000,         // $5M maximum volume
    volumeTimeframe: "24h",     // 24 hour timeframe
    minMarketCap: 300000,       // $300k minimum market cap
    maxMarketCap: 10000000,     // $10M maximum market cap
    // NO LIMIT - get all available coins that match criteria
    page: 1                     // First page
  };

  console.log(`üö® ONE API CALL - Fetching ALL matching coins (no limit)`);
  const response = await makeSolanaTrackerRequest('/search', searchParams);
  
  if (response.status !== 'success' || !response.data) {
    throw new Error('Invalid response from Solana Tracker');
  }

  const tokens = response.data;
  console.log(`üåô Got ${tokens.length} tokens in this batch`);

  // Format tokens for frontend
  const formattedTokens = tokens.map((token, index) => ({
    mintAddress: token.mint,
    name: token.name || 'Unknown',
    symbol: token.symbol || 'UNKNOWN',
    image: token.image || `https://via.placeholder.com/64/00d4ff/ffffff?text=${(token.symbol || 'T').charAt(0)}`,
    profileImage: token.image || `https://via.placeholder.com/64/00d4ff/ffffff?text=${(token.symbol || 'T').charAt(0)}`,
    logo: token.image || `https://via.placeholder.com/64/00d4ff/ffffff?text=${(token.symbol || 'T').charAt(0)}`,
    price_usd: token.priceUsd || 0,
    market_cap_usd: token.marketCapUsd || 0,
    volume_24h_usd: token.volume_24h || 0,
    liquidity: token.liquidity || 0,
    liquidity_usd: token.liquidityUsd || token.liquidity || 0,
    created_timestamp: token.createdAt ? new Date(token.createdAt).getTime() : Date.now(),
    description: token.description || '',
    // Additional fields for compatibility
    buys_24h: token.buys_24h || 0,
    sells_24h: token.sells_24h || 0,
    transactions_24h: (token.buys_24h || 0) + (token.sells_24h || 0),
    priority: index + 1 // Simple priority based on API order
  }));
  
  // Apply priority scoring like in trending endpoint
  const coinsWithPriority = rugcheckService.sortCoinsByPriority(formattedTokens);

  console.log(`üîç Final result: ${coinsWithPriority.length} coins after priority sorting`);
  
  return coinsWithPriority;
}

// Enhanced enrichment function with Rugcheck integration
async function enrichCoinsWithRugcheck(coins) {
  console.log(`üîç Checking ${coins.length} coins with Rugcheck for liquidity locks...`);
  
  // Extract mint addresses for batch checking
  const mintAddresses = coins.map(coin => 
    coin.mintAddress || coin.tokenAddress || coin.address
  ).filter(Boolean);

  if (mintAddresses.length === 0) {
    console.log('‚ö†Ô∏è No valid mint addresses found for Rugcheck analysis');
    return coins;
  }

  // Batch check with Rugcheck (limited to avoid rate limits)
  const rugcheckResults = await rugcheckService.checkMultipleTokens(mintAddresses, {
    maxConcurrent: 2,     // Lower concurrency to be respectful
    batchDelay: 1500,     // 1.5s between batches
    maxTokens: 30         // Limit to 30 tokens to avoid overwhelming the API
  });
  
  // Map results back to coins
  const enrichedCoins = coins.map(coin => {
    const mintAddress = coin.mintAddress || coin.tokenAddress || coin.address;
    const rugcheckData = rugcheckResults.find(r => r.address === mintAddress);
    
    if (rugcheckData && rugcheckData.rugcheckAvailable) {
      return {
        ...coin,
        // Rugcheck data takes precedence for liquidity lock status
        liquidityLocked: rugcheckData.liquidityLocked,
        lockPercentage: rugcheckData.lockPercentage,
        burnPercentage: rugcheckData.burnPercentage,
        rugcheckScore: rugcheckData.score,
        riskLevel: rugcheckData.riskLevel,
        freezeAuthority: rugcheckData.freezeAuthority,
        mintAuthority: rugcheckData.mintAuthority,
        topHolderPercent: rugcheckData.topHolderPercent,
        isHoneypot: rugcheckData.isHoneypot,
        rugcheckVerified: true
      };
    }
    
    // Keep existing data if Rugcheck is unavailable
    return {
      ...coin,
      rugcheckVerified: false
    };
  });

  const lockedCount = enrichedCoins.filter(coin => coin.liquidityLocked).length;
  const verifiedCount = enrichedCoins.filter(coin => coin.rugcheckVerified).length;
  
  console.log(`‚úÖ Rugcheck enrichment complete: ${verifiedCount}/${enrichedCoins.length} verified, ${lockedCount} have locked liquidity`);
  
  return enrichedCoins;
}

// Start Rugcheck auto-processor
function startRugcheckAutoProcessor() {
  // Stop any existing processor
  rugcheckAutoProcessor.stop();
  
  // Start processor with reference to currentCoins
  rugcheckAutoProcessor.start(() => currentCoins);
  
  console.log('üîç Rugcheck auto-processor started for current batch');
}

// Routes

// Root route for basic connectivity test
app.get('/', (req, res) => {
  res.json({
    message: 'Moonfeed Backend API',
    status: 'running',
    timestamp: new Date().toISOString(),
    endpoints: {
      health: '/health',
      trending: '/api/coins/trending',
      fast: '/api/coins/fast'
    }
  });
});

// Health check endpoints (both /health and /api/health for compatibility)
// These endpoints respond immediately, even during startup
const healthCheck = (req, res) => {
  const stats = coinStorage ? coinStorage.getStats() : { totalCoins: 0, lastUpdate: null };
  const priceEngineStatus = priceEngine ? priceEngine.getStatus() : { isRunning: false, clientCount: 0 };
  
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    service: 'moonfeed-batch-backend',
    uptime: process.uptime(),
    currentCoins: currentCoins ? currentCoins.length : 0,
    storage: stats,
    hasApiKey: !!SOLANA_TRACKER_API_KEY,
    priceEngine: priceEngineStatus,
    initialization: currentCoins.length > 0 ? 'complete' : 'pending'
  });
};

app.get('/health', healthCheck);
app.get('/api/health', healthCheck);

// Chart API for PriceHistoryChart component
app.get('/api/chart/:tokenAddress', async (req, res) => {
  try {
    const { tokenAddress } = req.params;
    const { timeframe = '1D' } = req.query;
    
    console.log(`üìä Chart API called for token: ${tokenAddress}, timeframe: ${timeframe}`);
    
    const priceHistoryService = require('./priceHistoryService');
    const chartData = await priceHistoryService.getChartData(tokenAddress, timeframe);
    
    res.json({
      success: true,
      data: chartData
    });
    
  } catch (error) {
    console.error('‚ùå Chart API error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Get current coins with priceEngine integration (optimized)
app.get('/api/coins/trending', async (req, res) => {
  try {
    console.log('üî• /api/coins/trending endpoint called (priceEngine-optimized)');
    
    const limit = parseInt(req.query.limit) || 50;
    const sortBy = req.query.sortBy || 'trending';
    
    let coins = [];
    let dataSource = 'priceEngine';
    
    // Get live data from priceEngine
    if (global.priceEngine) {
      console.log('‚ö° Getting live data from priceEngine...');
      
      try {
        // Get enriched data with live prices from priceEngine
        const liveData = global.priceEngine.getPricesData();
        
        if (liveData && liveData.length > 0) {
          console.log(`üìä PriceEngine has ${liveData.length} coins with live data`);
          coins = liveData;
          dataSource = 'priceEngine-live';
        } else {
          console.log('üì¶ PriceEngine empty, using global cache...');
          // Fallback to global cache if priceEngine is empty
          coins = global.coinsCache || [];
          dataSource = 'global-cache';
        }
      } catch (priceEngineError) {
        console.warn('‚ö†Ô∏è PriceEngine error, falling back to global cache:', priceEngineError.message);
        coins = global.coinsCache || [];
        dataSource = 'cache-fallback';
      }
    } else {
      console.log('üì¶ PriceEngine not available, using global cache...');
      coins = global.coinsCache || [];
      dataSource = 'cache-only';
    }
    
    // Merge Jupiter Live Prices into coin data
    if (coins.length > 0 && jupiterLivePriceService && jupiterLivePriceService.isRunning) {
      console.log('ü™ê Merging Jupiter live prices into coin data...');
      let jupiterPriceUpdates = 0;
      
      coins = coins.map(coin => {
        const address = coin.mintAddress || coin.address || coin.tokenAddress;
        if (address) {
          const livePrice = jupiterLivePriceService.getPrice(address);
          if (livePrice && livePrice.price > 0) {
            // Update coin with live Jupiter price
            const updatedCoin = {
              ...coin,
              price: livePrice.price,
              currentPrice: livePrice.price,
              priceSource: 'jupiter-live',
              priceTimestamp: livePrice.timestamp,
              priceChange: livePrice.priceChangeInstant || 0,
              lastJupiterUpdate: livePrice.timestamp
            };
            jupiterPriceUpdates++;
            return updatedCoin;
          }
        }
        return coin;
      });
      
      console.log(`ü™ê Updated ${jupiterPriceUpdates} coins with Jupiter live prices`);
      if (jupiterPriceUpdates > 0) {
        dataSource += '-jupiter-enhanced';
      }
    } else {
      console.log('‚ö†Ô∏è Jupiter Live Price Service not available for price merging');
    }
    
    // Sort coins based on requested criteria
    if (coins.length > 0) {
      switch (sortBy) {
        case 'volume':
          coins.sort((a, b) => (b.volume24h || b.volume_24h || 0) - (a.volume24h || a.volume_24h || 0));
          break;
        case 'latest':
          coins.sort((a, b) => (b.created_at || b.createdAt || 0) - (a.created_at || a.createdAt || 0));
          break;
        case 'trending':
        default:
          // Use priority scoring with live data preference
          coins.sort((a, b) => {
            // Prioritize coins with live price data
            if (a.currentPrice && !b.currentPrice) return -1;
            if (!a.currentPrice && b.currentPrice) return 1;
            
            // Sort by market cap or priority score
            const aMarketCap = a.marketCap || a.market_cap_usd || a.market_cap || 0;
            const bMarketCap = b.marketCap || b.market_cap_usd || b.market_cap || 0;
            
            if (aMarketCap && bMarketCap) return bMarketCap - aMarketCap;
            
            // Fallback to priority score if available
            const aPriority = a.priorityScore?.score || 0;
            const bPriority = b.priorityScore?.score || 0;
            return bPriority - aPriority;
          });
          break;
      }
    }
    
    // Apply pagination
    const paginatedCoins = coins.slice(0, limit);
    
    // Calculate statistics
    const liveDataCount = paginatedCoins.filter(coin => coin.currentPrice).length;
    const livePriceRate = paginatedCoins.length > 0 ? ((liveDataCount / paginatedCoins.length) * 100).toFixed(1) : '0';
    
    console.log(`üìä Trending result: ${paginatedCoins.length} coins, ${liveDataCount} with live prices (${livePriceRate}%)`);
    
    res.json({
      success: true,
      coins: paginatedCoins,
      count: paginatedCoins.length,
      total: coins.length,
      live_data_count: liveDataCount,
      live_price_rate: `${livePriceRate}%`,
      data_source: dataSource,
      sort_by: sortBy,
      timestamp: new Date().toISOString(),
      // Legacy compatibility
      source: dataSource,
      jupiter_enhanced: liveDataCount, // For compatibility
      enhancement_rate: `${livePriceRate}%` // For compatibility
    });
    
  } catch (error) {
    console.error('‚ùå Error in trending endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch trending tokens',
      details: error.message
    });
  }
});

// Volume-based coins with Jupiter enhancement
app.get('/api/coins/solana-volume', async (req, res) => {
  try {
    console.log('üìä /api/coins/solana-volume endpoint called (Jupiter-enhanced)');
    
    const limit = parseInt(req.query.limit) || 50;
    const useJupiterPrimary = req.query.jupiter !== 'false';
    
    let coins = [];
    let dataSource = 'unknown';
    
    if (useJupiterPrimary) {
      try {
        console.log('ü™ê Fetching volume-focused tokens from Jupiter...');
        
        // Get tokens with high trading activity
        const jupiterCoins = await jupiterDataService.getTopTokensByCategory(
          'toptraded', 
          '24h', 
          Math.min(limit * 2, 100)
        );
        
        if (jupiterCoins && jupiterCoins.length > 0) {
          // Filter and sort by volume
          const volumeCoins = jupiterCoins
            .filter(coin => {
              const skipSymbols = ['SOL', 'USDC', 'USDT'];
              return !skipSymbols.includes(coin.symbol) && 
                     coin.volume_24h_usd > 10000 && // Minimum $10k volume
                     coin.market_cap_usd < 50000000; // Under $50M for meme focus
            })
            .sort((a, b) => (b.volume_24h_usd || 0) - (a.volume_24h_usd || 0))
            .slice(0, limit);
          
          coins = volumeCoins;
          dataSource = 'jupiter-volume-primary';
          console.log(`‚úÖ Got ${coins.length} volume-focused Jupiter coins`);
        }
      } catch (jupiterError) {
        console.warn('‚ö†Ô∏è Jupiter volume API failed:', jupiterError.message);
      }
    }
    
    // Fallback to enhanced stored coins
    if (coins.length === 0 && currentCoins.length > 0) {
      console.log('üì¶ Using stored coins with Jupiter volume enhancement...');
      
      try {
        const coinsToEnhance = rugcheckService.sortCoinsByPriority(currentCoins)
          .slice(0, Math.min(limit, 15));
        
        const enhancedCoins = await jupiterDataService.batchEnrichCoins(coinsToEnhance, 3);
        
        // Sort by volume (Jupiter data preferred)
        coins = enhancedCoins.sort((a, b) => {
          const aVolume = a.volume_24h_usd || a.volume_24h || 0;
          const bVolume = b.volume_24h_usd || b.volume_24h || 0;
          return bVolume - aVolume;
        });
        
        dataSource = 'hybrid-volume-enhanced';
        
      } catch (enhanceError) {
        console.warn('‚ö†Ô∏è Enhancement failed, using raw coins:', enhanceError.message);
        coins = rugcheckService.sortCoinsByPriority(currentCoins).slice(0, limit);
        dataSource = 'stored-volume-fallback';
      }
    }
    
    const enhancedCount = coins.filter(coin => coin.jupiterEnriched).length;
    
    res.json({
      success: true,
      coins: coins,
      count: coins.length,
      total: currentCoins.length,
      jupiter_enhanced: enhancedCount,
      data_source: dataSource,
      timestamp: new Date().toISOString(),
      source: dataSource // Legacy compatibility
    });
    
  } catch (error) {
    console.error('‚ùå Error in volume endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch volume tokens',
      details: error.message
    });
  }
});

// Latest coins (sort by age/creation time)
app.get('/api/coins/solana-latest', (req, res) => {
  try {
    console.log('üÜï /api/coins/solana-latest endpoint called');
    
    const limit = parseInt(req.query.limit) || currentCoins.length;
    
    // Filter for newer coins (less than 7 days old) then apply priority sorting
    const recentCoins = currentCoins.filter(coin => (coin.age || 0) < 168); // 168 hours = 7 days
    const coins = rugcheckService.sortCoinsByPriority(recentCoins)
      .slice(0, limit);
    
    console.log(`üÜï First recent coin after priority sorting: ${coins[0]?.symbol} (Age: ${coins[0]?.age}h, Score: ${coins[0]?.priorityScore?.score?.toFixed(1)})`);
    
    res.json({
      success: true,
      coins: coins,
      count: coins.length,
      total: currentCoins.length,
      timestamp: new Date().toISOString(),
      source: 'batch-storage-latest'
    });
    
  } catch (error) {
    console.error('‚ùå Error in latest endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch latest tokens',
      details: error.message
    });
  }
});

// Fast coins endpoint - serves raw data immediately (no enrichment)
app.get('/api/coins/fast', (req, res) => {
  try {
    console.log('‚ö° /api/coins/fast endpoint called (priceEngine-optimized)');
    
    const limit = parseInt(req.query.limit) || 50;
    
    let sourceCoins = [];
    let dataSource = 'unknown';
    
    // Try to get fast data from priceEngine first
    if (global.priceEngine) {
      try {
        const liveData = global.priceEngine.getPricesData();
        if (liveData && liveData.length > 0) {
          sourceCoins = liveData;
          dataSource = 'priceEngine-fast';
          console.log(`‚ö° Using ${liveData.length} coins from priceEngine for fast response`);
        } else {
          sourceCoins = currentCoins;
          dataSource = 'cache-fast';
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è PriceEngine error in fast endpoint, using cache:', error.message);
        sourceCoins = currentCoins;
        dataSource = 'cache-fallback';
      }
    } else {
      sourceCoins = currentCoins;
      dataSource = 'cache-only';
    }
    
    if (!sourceCoins || sourceCoins.length === 0) {
      return res.json({
        success: true,
        coins: [],
        count: 0,
        total: 0,
        message: 'No coins available in cache',
        timestamp: new Date().toISOString(),
        source: dataSource
      });
    }
    
    // Merge Jupiter Live Prices into fast coin data
    if (sourceCoins.length > 0 && jupiterLivePriceService && jupiterLivePriceService.isRunning) {
      console.log('ü™ê Merging Jupiter live prices into fast endpoint...');
      let jupiterPriceUpdates = 0;
      
      sourceCoins = sourceCoins.map(coin => {
        const address = coin.mintAddress || coin.address || coin.tokenAddress;
        if (address) {
          const livePrice = jupiterLivePriceService.getPrice(address);
          if (livePrice && livePrice.price > 0) {
            // Update coin with live Jupiter price
            const updatedCoin = {
              ...coin,
              price: livePrice.price,
              currentPrice: livePrice.price,
              priceSource: 'jupiter-live',
              priceTimestamp: livePrice.timestamp,
              priceChange: livePrice.priceChangeInstant || 0,
              lastJupiterUpdate: livePrice.timestamp
            };
            jupiterPriceUpdates++;
            return updatedCoin;
          }
        }
        return coin;
      });
      
      console.log(`ü™ê Updated ${jupiterPriceUpdates} coins with Jupiter live prices in fast endpoint`);
      if (jupiterPriceUpdates > 0) {
        dataSource += '-jupiter-enhanced';
      }
    }
    
    // Serve coins with live data when available
    const fastCoins = sourceCoins.slice(0, limit).map(coin => ({
      // Essential data for immediate UI display
      mintAddress: coin.mintAddress || coin.address,
      address: coin.mintAddress || coin.address,
      symbol: coin.symbol,
      name: coin.name,
      image: coin.image || coin.profileImage || coin.logo,
      
      // Market data - prioritize live data from priceEngine
      price_usd: coin.currentPrice || coin.price_usd || coin.priceUsd || coin.price || 0,
      market_cap_usd: coin.marketCap || coin.market_cap_usd || coin.marketCap || 0,
      liquidity_usd: coin.liquidity || coin.liquidity_usd || coin.liquidity?.usd || 0,
      volume_24h_usd: coin.volume24h || coin.volume_24h_usd || coin.volume24h || coin.volume || 0,
      
      // Price changes - use live data when available
      priceChange24h: coin.priceChangePercent || coin.priceChange24h || 0,
      priceChange1h: coin.priceChange1h || 0,
      priceChange5m: coin.priceChange5m || 0,
      
      // Transaction data
      buys_24h: coin.buys_24h || 0,
      sells_24h: coin.sells_24h || 0,
      transactions_24h: coin.transactions_24h || (coin.buys_24h || 0) + (coin.sells_24h || 0),
      
      // Basic metadata
      created_timestamp: coin.created_timestamp,
      createdAt: coin.createdAt,
      description: coin.description || '',
      website: coin.website,
      twitter: coin.twitter,
      telegram: coin.telegram,
      
      // Flags
      isScam: coin.isScam || false,
      isPumpFun: coin.isPumpFun || false,
      
      // Source tracking
      source: dataSource,
      enriched: !!coin.currentPrice, // Mark as enriched if it has live price data
      hasLiveData: !!coin.currentPrice,
      lastUpdated: coin.lastUpdated || new Date().toISOString()
    }));
    
    const liveDataCount = fastCoins.filter(coin => coin.hasLiveData).length;
    
    res.json({
      success: true,
      coins: fastCoins,
      count: fastCoins.length,
      total: sourceCoins.length,
      live_data_count: liveDataCount,
      live_data_rate: fastCoins.length > 0 ? `${((liveDataCount / fastCoins.length) * 100).toFixed(1)}%` : '0%',
      message: 'Optimized coin data with live prices when available',
      data_source: dataSource,
      enrichment: {
        status: liveDataCount > 0 ? 'partial' : 'pending',
        note: 'Use /api/coins/enrich endpoint to get enriched data with banners and security analysis'
      },
      timestamp: new Date().toISOString(),
      source: dataSource
    });
    
  } catch (error) {
    console.error('‚ùå Error in fast endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to serve fast coin data',
      details: error.message
    });
  }
});

// Main curated coins endpoint (alias for trending)
app.get('/api/coins/curated', (req, res) => {
  try {
    console.log('üîç /api/coins/curated endpoint called');
    
    const limit = parseInt(req.query.limit) || currentCoins.length;
    
    // Use priority sorting for curated coins
    const coins = rugcheckService.sortCoinsByPriority(currentCoins)
      .slice(0, limit);
    
    console.log(`üìä Serving ${coins.length} curated coins`);
    
    res.json({
      success: true,
      coins: coins,
      count: coins.length,
      total: currentCoins.length,
      timestamp: new Date().toISOString(),
      source: 'curated-batch'
    });
    
  } catch (error) {
    console.error('‚ùå Error in curated endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch curated coins',
      details: error.message
    });
  }
});

// Background enrichment endpoint - progressively enriches coins with banners and security data
app.post('/api/coins/background-enrich', async (req, res) => {
  try {
    const { 
      startIndex = 0, 
      batchSize = 10,
      includeBanners = true,
      includeRugcheck = true 
    } = req.body;
    
    if (currentCoins.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'No coins currently loaded'
      });
    }

    const totalCoins = currentCoins.length;
    const remainingCoins = totalCoins - startIndex;
    const coinsToProcess = Math.min(batchSize, remainingCoins);
    
    if (startIndex >= totalCoins) {
      return res.json({
        success: true,
        message: 'All coins have been enriched',
        progress: {
          processed: totalCoins,
          total: totalCoins,
          percentage: 100,
          completed: true
        }
      });
    }

    console.log(`üé® Background enrichment: Processing batch starting at index ${startIndex} (${coinsToProcess} coins)`);
    
    // Get the batch of coins to enrich
    const batchToProcess = currentCoins.slice(startIndex, startIndex + coinsToProcess);
    
    // Enrich this batch with DexScreener (banners) and Rugcheck (security)
    let enrichedBatch = [...batchToProcess];
    
    if (includeBanners) {
      console.log(`üé® Adding banners to ${enrichedBatch.length} coins...`);
      enrichedBatch = await Promise.all(enrichedBatch.map(async (coin) => {
        try {
          if (!coin.banner && !coin.enriched) {
            const enrichedCoin = await dexscreenerService.enrichCoin(coin, {
              includeBanners: true,
              forceBannerEnrichment: true
            });
            return enrichedCoin;
          }
          return coin;
        } catch (error) {
          console.log(`‚ö†Ô∏è Banner enrichment failed for ${coin.symbol}: ${error.message}`);
          return {
            ...coin,
            banner: coin.banner || dexscreenerService.generatePlaceholderBanner({ symbol: coin.symbol })
          };
        }
      }));
    }
    
    if (includeRugcheck) {
      console.log(`üîí Adding security analysis to ${enrichedBatch.length} coins...`);
      const mintAddresses = enrichedBatch.map(coin => coin.mintAddress).filter(Boolean);
      
      try {
        const rugcheckResults = await rugcheckService.checkMultipleTokens(mintAddresses, {
          maxConcurrent: 2,
          batchDelay: 1000,
          maxTokens: coinsToProcess
        });
        
        // Update batch with Rugcheck data
        enrichedBatch = enrichedBatch.map(coin => {
          const rugcheckData = rugcheckResults.find(r => r.address === coin.mintAddress);
          if (rugcheckData && rugcheckData.rugcheckAvailable) {
            return {
              ...coin,
              liquidityLocked: rugcheckData.liquidityLocked,
              lockPercentage: rugcheckData.lockPercentage,
              burnPercentage: rugcheckData.burnPercentage,
              rugcheckScore: rugcheckData.score,
              riskLevel: rugcheckData.riskLevel,
              rugcheckVerified: true,
              rugcheckProcessedAt: new Date().toISOString()
            };
          }
          return coin;
        });
      } catch (rugcheckError) {
        console.log(`‚ö†Ô∏è Rugcheck batch failed: ${rugcheckError.message}`);
      }
    }
    
    // Update the current coins array with enriched data
    for (let i = 0; i < enrichedBatch.length; i++) {
      currentCoins[startIndex + i] = enrichedBatch[i];
    }
    
    // Calculate progress
    const processedSoFar = startIndex + coinsToProcess;
    const progressPercentage = Math.round((processedSoFar / totalCoins) * 100);
    const nextIndex = processedSoFar;
    const hasMore = nextIndex < totalCoins;
    
    // Count enrichment stats
    const bannersAdded = enrichedBatch.filter(coin => coin.banner).length;
    const rugcheckAdded = enrichedBatch.filter(coin => coin.rugcheckVerified).length;
    const locksFound = enrichedBatch.filter(coin => coin.liquidityLocked).length;

    console.log(`‚úÖ Background enrichment batch complete: ${bannersAdded} banners, ${rugcheckAdded} rugcheck, ${locksFound} locks`);

    res.json({
      success: true,
      message: `Background enrichment batch ${Math.ceil(processedSoFar / batchSize)} completed`,
      batch: {
        startIndex,
        processed: coinsToProcess,
        bannersAdded,
        rugcheckAdded,
        locksFound
      },
      progress: {
        processed: processedSoFar,
        total: totalCoins,
        percentage: progressPercentage,
        completed: !hasMore
      },
      next: hasMore ? {
        startIndex: nextIndex,
        remaining: totalCoins - processedSoFar,
        estimatedBatches: Math.ceil((totalCoins - processedSoFar) / batchSize)
      } : null,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in background enrichment:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to perform background enrichment',
      details: error.message
    });
  }
});

// Enrich specific coins with DexScreener data for active viewing
app.post('/api/coins/enrich', async (req, res) => {
  try {
    const { mintAddresses } = req.body;
    
    if (!Array.isArray(mintAddresses) || mintAddresses.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'mintAddresses array is required'
      });
    }

    console.log(`üîç Enriching ${mintAddresses.length} coins with DexScreener data...`);
    
    // Find coins from current cache that match the requested addresses
    const coinsToEnrich = currentCoins.filter(coin => 
      mintAddresses.includes(coin.mintAddress)
    );

    if (coinsToEnrich.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'No matching coins found in cache'
      });
    }

    // Enrich coins with DexScreener data
    const enrichedCoins = await Promise.all(
      coinsToEnrich.map(async (coin) => {
        try {
          console.log(`üöÄ Enriching ${coin.symbol} (${coin.mintAddress})...`);
          const enrichedCoin = await dexscreenerService.enrichCoin(coin);
          
          // If no real banner was found, ensure we have a placeholder
          if (!enrichedCoin.banner) {
            enrichedCoin.banner = dexscreenerService.generatePlaceholderBanner({ symbol: coin.symbol });
          }
          
          return enrichedCoin;
        } catch (error) {
          console.error(`‚ùå Failed to enrich ${coin.symbol}:`, error.message);
          // Return original coin with placeholder banner if enrichment fails
          return {
            ...coin,
            banner: coin.banner || dexscreenerService.generatePlaceholderBanner({ symbol: coin.symbol })
          };
        }
      })
    );

    console.log(`‚úÖ Successfully enriched ${enrichedCoins.length} coins`);

    res.json({
      success: true,
      coins: enrichedCoins,
      count: enrichedCoins.length,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Error in enrichment endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to enrich coins',
      details: error.message
    });
  }
});

// Force enrichment of all current coins with DexScreener data (including banners and market data)
app.post('/api/coins/force-enrich', async (req, res) => {
  try {
    const { includeBanners = true, includeMarketData = true } = req.body;
    
    console.log(`üé® Force enriching ${currentCoins.length} coins with DexScreener data...`);
    console.log(`üìä Include banners: ${includeBanners}, Include market data: ${includeMarketData}`);
    
    if (currentCoins.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'No coins available to enrich'
      });
    }

    // Enrich all current coins with enhanced options
    const enrichedCoins = await dexscreenerService.enrichCoins(currentCoins, {
      useBatchApi: true,
      batchSize: 25,
      batchDelay: 1200,
      maxToEnrich: currentCoins.length, // Enrich all coins
      forceBannerEnrichment: includeBanners
    });

    console.log(`üîç Adding Rugcheck verification to enriched coins...`);
    
    // Add Rugcheck enrichment for liquidity lock verification
    const finalEnrichedCoins = await enrichCoinsWithRugcheck(enrichedCoins);

    // Update current serving coins with enriched data
    currentCoins = finalEnrichedCoins;
    
    // Detailed analytics
    const coinsWithBanners = finalEnrichedCoins.filter(coin => coin.banner).length;
    const coinsWithRealBanners = finalEnrichedCoins.filter(coin => 
      coin.banner && !coin.banner.includes('dicebear.com') && !coin.banner.includes('placeholder')
    ).length;
    
    const coinsWithMarketData = finalEnrichedCoins.filter(coin => 
      coin.market_cap_usd || coin.volume_24h_usd || coin.liquidity_usd
    ).length;
    
    const coinsWithDexScreenerData = finalEnrichedCoins.filter(coin => coin.dexscreener).length;
    const coinsWithRugcheckData = finalEnrichedCoins.filter(coin => coin.rugcheckVerified).length;
    const coinsWithLockedLiquidity = finalEnrichedCoins.filter(coin => coin.liquidityLocked).length;
    
    const enrichmentQuality = finalEnrichedCoins.reduce((acc, coin) => {
      if (coin.enrichmentQuality) {
        acc.withImage += coin.enrichmentQuality.hasImage ? 1 : 0;
        acc.withSocials += coin.enrichmentQuality.hasSocials ? 1 : 0;
        acc.withDescription += coin.enrichmentQuality.hasDescription ? 1 : 0;
        acc.withMarketData += coin.enrichmentQuality.hasMarketData ? 1 : 0;
      }
      return acc;
    }, { withImage: 0, withSocials: 0, withDescription: 0, withMarketData: 0 });

    console.log(`‚úÖ Successfully enriched ${finalEnrichedCoins.length} coins`);
    console.log(`üé® Banners: ${coinsWithBanners} total, ${coinsWithRealBanners} real (from DexScreener)`);
    console.log(`üìä Market data: ${coinsWithMarketData}/${finalEnrichedCoins.length} coins have enhanced market metrics`);
    console.log(`üîç Rugcheck: ${coinsWithRugcheckData}/${finalEnrichedCoins.length} verified, ${coinsWithLockedLiquidity} have locked liquidity`);

    res.json({
      success: true,
      message: 'All coins enriched with comprehensive DexScreener and Rugcheck data',
      stats: {
        total: finalEnrichedCoins.length,
        enriched: finalEnrichedCoins.filter(coin => coin.enriched).length,
        withDexScreenerData: coinsWithDexScreenerData,
        withRugcheckData: coinsWithRugcheckData,
        withLockedLiquidity: coinsWithLockedLiquidity,
        banners: {
          total: coinsWithBanners,
          real: coinsWithRealBanners,
          placeholder: coinsWithBanners - coinsWithRealBanners
        },
        marketData: {
          enhanced: coinsWithMarketData,
          percentage: Math.round((coinsWithMarketData / finalEnrichedCoins.length) * 100)
        },
        rugcheck: {
          verified: coinsWithRugcheckData,
          verificationRate: Math.round((coinsWithRugcheckData / finalEnrichedCoins.length) * 100),
          lockedLiquidity: coinsWithLockedLiquidity,
          lockRate: Math.round((coinsWithLockedLiquidity / finalEnrichedCoins.length) * 100)
        },
        quality: enrichmentQuality
      },
      sampleEnrichedCoin: finalEnrichedCoins.find(coin => coin.enriched && coin.dexscreener) || null,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in force enrichment:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to enrich coins',
      details: error.message
    });
  }
});

// Manual refresh - ONE API call, save as new batch
app.post('/api/refresh', async (req, res) => {
  try {
    const { confirm } = req.body;
    
    if (confirm !== 'yes') {
      return res.status(400).json({
        error: 'Manual confirmation required',
        message: 'Send POST request with body: {"confirm": "yes"} to fetch new batch',
        warning: 'This will consume API credits!',
        example: 'curl -X POST http://localhost:3001/api/refresh -H "Content-Type: application/json" -d \'{"confirm": "yes"}\''
      });
    }

    if (!SOLANA_TRACKER_API_KEY) {
      return res.status(400).json({
        error: 'API key not configured',
        message: 'SOLANA_TRACKER_API_KEY environment variable is required'
      });
    }

    console.log('üö® MANUAL BATCH REFRESH - ONE API CALL for ALL coins!');
    const freshCoinBatch = await fetchFreshCoinBatch();
    
    // Save as new batch (auto-rotates old ones)
    coinStorage.saveBatch(freshCoinBatch);
    
    // Update current serving coins
    currentCoins = freshCoinBatch;
    
    // Start Rugcheck auto-processor for new batch
    startRugcheckAutoProcessor();
    
    res.json({
      success: true,
      message: 'New batch fetched and saved, Rugcheck auto-processor started',
      batchSize: freshCoinBatch.length,
      timestamp: new Date().toISOString(),
      warning: 'API credits consumed',
      storage: coinStorage.getStats()
    });
    
  } catch (error) {
    console.error('‚ùå Batch refresh failed:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to refresh batch',
      details: error.message
    });
  }
});

// Get storage/batch stats
app.get('/api/storage/stats', (req, res) => {
  const stats = coinStorage.getStats();
  const dexCacheStats = dexscreenerService.getCacheStats();
  const jupiterCacheStats = jupiterTokenService.getCacheStats();
  const jupiterDataStats = jupiterDataService.getCacheStats();
  const metadataStats = tokenMetadataService.getCacheStats();
  
  res.json({
    storage: stats,
    currentServing: currentCoins.length,
    enrichment: {
      dexscreenerCache: dexCacheStats,
      jupiterTokenCache: jupiterCacheStats,
      jupiterDataCache: jupiterDataStats,
      metadataCache: metadataStats,
      enrichedCoins: currentCoins.filter(coin => coin.enriched).length,
      jupiterEnhancedCoins: currentCoins.filter(coin => coin.jupiterEnriched).length,
      metadataEnhancedCoins: currentCoins.filter(coin => coin.metadataEnriched).length
    },
    jupiter_integration: {
      status: 'active',
      primary_endpoints: [
        '/api/coins/trending (Jupiter-enhanced)',
        '/api/coins/solana-volume (Jupiter-enhanced)',
        '/api/coins/jupiter-trending (Jupiter-primary)',
        '/api/coins/jupiter-enhanced (Hybrid)',
        '/api/coins/metadata-enhanced (Metadata-focused)',
        '/api/tokens/:mintAddress/metadata (Individual metadata)'
      ],
      features: [
        'Real-time price/market data',
        'Holder count tracking',
        'Organic quality scores',
        'Security audit status',
        'Verification badges',
        'Trading analytics',
        'Comprehensive metadata',
        'Social media links',
        'Token descriptions',
        'Official website detection'
      ]
    },
    instructions: {
      refresh: 'POST /api/refresh with body: {"confirm": "yes"}',
      warning: 'ONE API call will fetch ALL matching coins and save as new batch'
    },
    timestamp: new Date().toISOString()
  });
});

// Clean DexScreener cache endpoint
app.post('/api/cache/clean', (req, res) => {
  const cleaned = dexscreenerService.cleanCache();
  res.json({
    success: true,
    message: `Cleaned ${cleaned} expired cache entries`,
    cacheStats: dexscreenerService.getCacheStats(),
    timestamp: new Date().toISOString()
  });
});

// Jupiter Token API Endpoints

// Get token info from Jupiter
app.get('/api/jupiter/token/:mintAddress', async (req, res) => {
  try {
    const { mintAddress } = req.params;
    
    if (!mintAddress) {
      return res.status(400).json({
        error: 'Mint address required'
      });
    }

    console.log(`ü™ê Getting Jupiter token info for ${mintAddress}`);
    
    const tokenInfo = await jupiterTokenService.getTokenInfo(mintAddress);
    
    if (!tokenInfo) {
      return res.status(404).json({
        error: 'Token not found in Jupiter registry',
        mintAddress
      });
    }
    
    res.json({
      success: true,
      token: tokenInfo,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Error getting Jupiter token info:', error);
    res.status(500).json({
      error: 'Failed to get token info',
      details: error.message
    });
  }
});

// Search Jupiter tokens
app.get('/api/jupiter/search', async (req, res) => {
  try {
    const { q: query, limit = 20 } = req.query;
    
    if (!query) {
      return res.status(400).json({
        error: 'Query parameter "q" required'
      });
    }

    console.log(`üîç Searching Jupiter tokens for: ${query}`);
    
    const results = await jupiterTokenService.searchTokens(query, parseInt(limit));
    
    res.json({
      success: true,
      query,
      results,
      count: results.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Error searching Jupiter tokens:', error);
    res.status(500).json({
      error: 'Failed to search tokens',
      details: error.message
    });
  }
});

// Get tokens by tag from Jupiter
app.get('/api/jupiter/tags/:tag', async (req, res) => {
  try {
    const { tag } = req.params;
    const { limit = 50 } = req.query;
    
    console.log(`üè∑Ô∏è Getting Jupiter tokens with tag: ${tag}`);
    
    const results = await jupiterTokenService.getTokensByTag(tag, parseInt(limit));
    
    res.json({
      success: true,
      tag,
      results,
      count: results.length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Error getting tokens by tag:', error);
    res.status(500).json({
      error: 'Failed to get tokens by tag',
      details: error.message
    });
  }
});

// Batch get Jupiter token info
app.post('/api/jupiter/batch', async (req, res) => {
  try {
    const { mintAddresses, limit = 10 } = req.body;
    
    if (!mintAddresses || !Array.isArray(mintAddresses)) {
      return res.status(400).json({
        error: 'mintAddresses array required'
      });
    }

    if (mintAddresses.length > limit) {
      return res.status(400).json({
        error: `Too many addresses. Maximum ${limit} allowed per batch`
      });
    }

    console.log(`üìö Batch getting Jupiter info for ${mintAddresses.length} tokens`);
    
    const results = await jupiterTokenService.batchGetTokens(mintAddresses);
    
    res.json({
      success: true,
      results,
      count: results.length,
      found: results.filter(r => r.found !== false).length,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Error in batch Jupiter request:', error);
    res.status(500).json({
      error: 'Failed to batch get token info',
      details: error.message
    });
  }
});

// Get Jupiter cache stats
app.get('/api/jupiter/cache/stats', (req, res) => {
  try {
    const stats = jupiterTokenService.getCacheStats();
    
    res.json({
      success: true,
      cache: stats,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Error getting Jupiter cache stats:', error);
    res.status(500).json({
      error: 'Failed to get cache stats',
      details: error.message
    });
  }
});

// Clear Jupiter cache
app.post('/api/jupiter/cache/clear', (req, res) => {
  try {
    jupiterTokenService.clearCache();
    
    res.json({
      success: true,
      message: 'Jupiter token cache cleared',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Error clearing Jupiter cache:', error);
    res.status(500).json({
      error: 'Failed to clear cache',
      details: error.message
    });
  }
});

// Jupiter Data Service Endpoints (Enhanced Market Data)

// Get trending coins using Jupiter as primary data source
app.get('/api/coins/jupiter-trending', async (req, res) => {
  try {
    const { 
      limit = 50, 
      category = 'toporganicscore', 
      interval = '24h' 
    } = req.query;
    
    console.log(`ü™ê Getting trending coins from Jupiter (${category}, ${interval})`);
    
    const jupiterCoins = await jupiterDataService.getTopTokensByCategory(
      category, 
      interval, 
      parseInt(limit)
    );
    
    res.json({
      success: true,
      coins: jupiterCoins,
      count: jupiterCoins.length,
      category,
      interval,
      source: 'jupiter-primary',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in Jupiter trending endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch Jupiter trending tokens',
      details: error.message
    });
  }
});

// Enhance existing coins with Jupiter data
app.post('/api/coins/enhance-with-jupiter', async (req, res) => {
  try {
    const { coins, maxConcurrency = 5 } = req.body;
    
    if (!coins || !Array.isArray(coins)) {
      return res.status(400).json({
        error: 'coins array required'
      });
    }
    
    console.log(`ü™ê Enhancing ${coins.length} coins with Jupiter data`);
    
    const enhancedCoins = await jupiterDataService.batchEnrichCoins(coins, maxConcurrency);
    
    const enhancedCount = enhancedCoins.filter(coin => coin.jupiterEnriched).length;
    
    res.json({
      success: true,
      coins: enhancedCoins,
      count: enhancedCoins.length,
      enhanced_count: enhancedCount,
      enhancement_rate: `${((enhancedCount / enhancedCoins.length) * 100).toFixed(1)}%`,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error enhancing coins with Jupiter:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to enhance coins with Jupiter data',
      details: error.message
    });
  }
});

// Get hybrid data (current coins enhanced with Jupiter)
app.get('/api/coins/jupiter-enhanced', async (req, res) => {
  try {
    const { limit = 50 } = req.query;
    
    console.log(`ü™ê Getting current coins enhanced with Jupiter data`);
    
    // Take current coins and enhance them with Jupiter
    const coinsToEnhance = currentCoins.slice(0, parseInt(limit));
    const enhancedCoins = await jupiterDataService.batchEnrichCoins(coinsToEnhance);
    
    // Sort by Jupiter metrics if available
    const sortedCoins = enhancedCoins.sort((a, b) => {
      // Prioritize Jupiter-enhanced coins
      if (a.jupiterEnriched && !b.jupiterEnriched) return -1;
      if (!a.jupiterEnriched && b.jupiterEnriched) return 1;
      
      // Sort by organic score if available
      if (a.organic_score && b.organic_score) {
        return b.organic_score - a.organic_score;
      }
      
      // Fallback to market cap
      return (b.market_cap_usd || 0) - (a.market_cap_usd || 0);
    });
    
    const enhancedCount = sortedCoins.filter(coin => coin.jupiterEnriched).length;
    
    res.json({
      success: true,
      coins: sortedCoins,
      count: sortedCoins.length,
      enhanced_count: enhancedCount,
      enhancement_rate: `${((enhancedCount / sortedCoins.length) * 100).toFixed(1)}%`,
      source: 'hybrid-jupiter-enhanced',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in Jupiter enhanced endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to get Jupiter enhanced coins',
      details: error.message
    });
  }
});

// Get tokens enriched with comprehensive metadata
app.get('/api/coins/metadata-enhanced', async (req, res) => {
  try {
    console.log('üìã /api/coins/metadata-enhanced endpoint called');
    
    const limit = parseInt(req.query.limit) || 50;
    const source = req.query.source || 'current'; // 'current' or 'jupiter'
    
    let baseCoins = [];
    
    if (source === 'jupiter') {
      // Get fresh tokens from Jupiter
      baseCoins = await jupiterDataService.getTopTokensByCategory('toporganicscore', '24h', limit);
    } else {
      // Use current coins and enhance with metadata
      baseCoins = currentCoins.slice(0, limit * 2); // Get more for filtering
    }
    
    // Enrich with metadata
    console.log(`üìã Enriching ${baseCoins.length} tokens with metadata...`);
    const enrichedCoins = await tokenMetadataService.batchEnrichWithMetadata(baseCoins, 3);
    
    // Sort by metadata quality and market data
    const sortedCoins = enrichedCoins
      .sort((a, b) => {
        // Prioritize tokens with good metadata
        const aScore = (a.metadataEnriched ? 100 : 0) + 
                      (a.website ? 20 : 0) + 
                      (a.twitter ? 15 : 0) + 
                      (a.telegram ? 15 : 0) + 
                      (a.description ? 25 : 0) + 
                      (a.isVerified ? 30 : 0) +
                      (a.jupiterMetadata?.organicScore || 0);
        
        const bScore = (b.metadataEnriched ? 100 : 0) + 
                      (b.website ? 20 : 0) + 
                      (b.twitter ? 15 : 0) + 
                      (b.telegram ? 15 : 0) + 
                      (b.description ? 25 : 0) + 
                      (b.isVerified ? 30 : 0) +
                      (b.jupiterMetadata?.organicScore || 0);
        
        return bScore - aScore;
      })
      .slice(0, limit);
    
    const metadataEnhancedCount = sortedCoins.filter(coin => coin.metadataEnriched).length;
    const hasSocialsCount = sortedCoins.filter(coin => coin.website || coin.twitter || coin.telegram).length;
    const hasDescriptionCount = sortedCoins.filter(coin => coin.description).length;
    
    res.json({
      success: true,
      coins: sortedCoins,
      count: sortedCoins.length,
      metadata_enhanced_count: metadataEnhancedCount,
      has_socials_count: hasSocialsCount,
      has_description_count: hasDescriptionCount,
      enhancement_rate: `${((metadataEnhancedCount / sortedCoins.length) * 100).toFixed(1)}%`,
      source: `metadata-enhanced-${source}`,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in metadata enhanced endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to get metadata enhanced coins',
      details: error.message
    });
  }
});

// Get metadata for a specific token
app.get('/api/tokens/:mintAddress/metadata', async (req, res) => {
  try {
    const { mintAddress } = req.params;
    const forceRefresh = req.query.refresh === 'true';
    
    console.log(`üìã Getting metadata for ${mintAddress} (refresh: ${forceRefresh})`);
    
    const metadata = await tokenMetadataService.getTokenMetadata(mintAddress, {
      forceRefresh,
      chainId: req.query.chain || 'solana'
    });
    
    // Format for frontend
    const frontendMetadata = tokenMetadataService.formatMetadataForFrontend(metadata);
    
    res.json({
      success: true,
      metadata: frontendMetadata,
      raw_metadata: metadata,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error(`‚ùå Error getting metadata for ${req.params.mintAddress}:`, error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to get token metadata',
      details: error.message
    });
  }
});

// Batch enrich existing coins with metadata
app.post('/api/coins/enrich-metadata', async (req, res) => {
  try {
    const { tokens, maxConcurrency = 3 } = req.body;
    
    if (!tokens || !Array.isArray(tokens)) {
      return res.status(400).json({
        success: false,
        error: 'Invalid tokens array provided'
      });
    }
    
    console.log(`üìã Batch enriching ${tokens.length} tokens with metadata...`);
    
    const enrichedTokens = await tokenMetadataService.batchEnrichWithMetadata(tokens, maxConcurrency);
    
    const enrichedCount = enrichedTokens.filter(token => token.metadataEnriched).length;
    
    res.json({
      success: true,
      tokens: enrichedTokens,
      count: enrichedTokens.length,
      enriched_count: enrichedCount,
      enhancement_rate: `${((enrichedCount / enrichedTokens.length) * 100).toFixed(1)}%`,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in batch metadata enrichment:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to enrich tokens with metadata',
      details: error.message
    });
  }
});

// Get metadata service statistics
app.get('/api/metadata/stats', (req, res) => {
  try {
    const stats = tokenMetadataService.getCacheStats();
    
    res.json({
      success: true,
      cache: stats,
      service: 'token-metadata-service',
      features: [
        'Jupiter metadata integration',
        'Dexscreener social links',
        'Token descriptions',
        'Social media validation',
        'Official website detection',
        'Multi-level caching'
      ],
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('Error getting metadata stats:', error);
    res.status(500).json({
      error: 'Failed to get metadata stats',
      details: error.message
    });
  }
});

// Rugcheck auto-processor status endpoint (must come before /:mintAddress route)
app.get('/api/rugcheck/auto-status', (req, res) => {
  try {
    const status = rugcheckAutoProcessor.getStatus();
    
    res.json({
      success: true,
      autoProcessor: status,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error getting auto-processor status:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to get auto-processor status',
      details: error.message
    });
  }
});

// Manually trigger Rugcheck auto-processor (must come before /:mintAddress route)
app.post('/api/rugcheck/auto-trigger', async (req, res) => {
  try {
    const result = await rugcheckAutoProcessor.triggerProcessing();
    
    res.json({
      success: result.success,
      message: result.message,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error triggering auto-processor:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to trigger auto-processor',
      details: error.message
    });
  }
});

// Start/stop Rugcheck auto-processor (must come before /:mintAddress route)
app.post('/api/rugcheck/auto-control', (req, res) => {
  try {
    const { action } = req.body; // 'start' or 'stop'
    
    if (action === 'start') {
      startRugcheckAutoProcessor();
      res.json({
        success: true,
        message: 'Rugcheck auto-processor started',
        timestamp: new Date().toISOString()
      });
    } else if (action === 'stop') {
      rugcheckAutoProcessor.stop();
      res.json({
        success: true,
        message: 'Rugcheck auto-processor stopped',
        timestamp: new Date().toISOString()
      });
    } else {
      res.status(400).json({
        success: false,
        error: 'Invalid action. Use "start" or "stop"'
      });
    }
    
  } catch (error) {
    console.error('‚ùå Error controlling auto-processor:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to control auto-processor',
      details: error.message
    });
  }
});

// Get current Rugcheck verification progress/status (must come before /:mintAddress route)
app.get('/api/rugcheck/progress', (req, res) => {
  try {
    const totalCoins = currentCoins.length;
    const processedCoins = currentCoins.filter(coin => coin.rugcheckProcessedAt).length;
    const verifiedCoins = currentCoins.filter(coin => coin.rugcheckVerified).length;
    const lockedCoins = currentCoins.filter(coin => coin.liquidityLocked && coin.rugcheckVerified).length;
    
    const unprocessedCoins = currentCoins.filter(coin => !coin.rugcheckProcessedAt);
    const nextBatchStart = totalCoins - unprocessedCoins.length;
    
    res.json({
      success: true,
      progress: {
        total: totalCoins,
        processed: processedCoins,
        verified: verifiedCoins,
        locked: lockedCoins,
        percentage: totalCoins > 0 ? Math.round((processedCoins / totalCoins) * 100) : 0,
        completed: processedCoins === totalCoins
      },
      stats: {
        verificationRate: verifiedCoins > 0 ? Math.round((verifiedCoins / processedCoins) * 100) : 0,
        lockRate: processedCoins > 0 ? Math.round((lockedCoins / processedCoins) * 100) : 0,
        lockedOfVerified: verifiedCoins > 0 ? Math.round((lockedCoins / verifiedCoins) * 100) : 0
      },
      next: unprocessedCoins.length > 0 ? {
        startIndex: nextBatchStart,
        remaining: unprocessedCoins.length,
        estimatedBatches: Math.ceil(unprocessedCoins.length / 30)
      } : null,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error getting Rugcheck progress:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to get progress',
      details: error.message
    });
  }
});

// Rugcheck batch verification endpoint (must come before /:mintAddress route)
app.get('/api/rugcheck/batch', async (req, res) => {
  try {
    const { addresses } = req.query;
    
    if (!addresses) {
      return res.status(400).json({
        success: false,
        error: 'addresses parameter is required (comma-separated)'
      });
    }
    
    const mintAddresses = addresses.split(',').map(addr => addr.trim()).slice(0, 10); // Limit to 10
    
    console.log(`üîç Rugcheck batch verification for ${mintAddresses.length} tokens`);
    
    const results = await rugcheckService.checkMultipleTokens(mintAddresses, {
      maxConcurrent: 2,
      batchDelay: 1000,
      maxTokens: 10
    });
    
    res.json({
      success: true,
      data: results.map(result => ({
        mintAddress: result.address,
        liquidityLocked: result.liquidityLocked,
        lockPercentage: result.lockPercentage,
        burnPercentage: result.burnPercentage,
        riskLevel: result.riskLevel,
        score: result.score,
        verified: result.rugcheckAvailable
      })),
      metadata: {
        totalChecked: results.length,
        lockedCount: results.filter(r => r.liquidityLocked).length,
        source: 'Rugcheck.xyz',
        checkedAt: new Date().toISOString()
      }
    });
    
  } catch (error) {
    console.error('‚ùå Error in Rugcheck batch verification:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to perform batch Rugcheck verification',
      details: error.message
    });
  }
});

// Get Rugcheck statistics for current coins
app.get('/api/rugcheck/stats', (req, res) => {
  try {
    const stats = {
      totalCoins: currentCoins.length,
      rugcheckVerified: currentCoins.filter(coin => coin.rugcheckVerified).length,
      liquidityLocked: currentCoins.filter(coin => coin.liquidityLocked).length,
      unlocked: currentCoins.filter(coin => coin.rugcheckVerified && !coin.liquidityLocked).length,
      riskLevels: {
        high: currentCoins.filter(coin => coin.riskLevel === 'high').length,
        medium: currentCoins.filter(coin => coin.riskLevel === 'medium').length,
        low: currentCoins.filter(coin => coin.riskLevel === 'low').length,
        unknown: currentCoins.filter(coin => !coin.riskLevel || coin.riskLevel === 'unknown').length
      },
      honeypots: currentCoins.filter(coin => coin.isHoneypot).length,
      averageScore: currentCoins
        .filter(coin => coin.rugcheckScore > 0)
        .reduce((sum, coin) => sum + coin.rugcheckScore, 0) / 
        currentCoins.filter(coin => coin.rugcheckScore > 0).length || 0
    };

    // Top 10 safest coins (highest lock percentage + lowest risk)
    const safestCoins = currentCoins
      .filter(coin => coin.rugcheckVerified)
      .sort((a, b) => {
        // Sort by lock percentage (desc) then by risk level (low=3, medium=2, high=1, unknown=0)
        const riskScore = (risk) => risk === 'low' ? 3 : risk === 'medium' ? 2 : risk === 'high' ? 1 : 0;
        const aScore = (a.lockPercentage || 0) + riskScore(a.riskLevel) * 10;
        const bScore = (b.lockPercentage || 0) + riskScore(b.riskLevel) * 10;
        return bScore - aScore;
      })
      .slice(0, 10)
      .map(coin => ({
        symbol: coin.symbol,
        name: coin.name,
        mintAddress: coin.mintAddress,
        lockPercentage: coin.lockPercentage,
        riskLevel: coin.riskLevel,
        score: coin.rugcheckScore,
        marketCap: coin.market_cap_usd
      }));

    res.json({
      success: true,
      stats,
      safestCoins,
      metadata: {
        verificationRate: Math.round((stats.rugcheckVerified / stats.totalCoins) * 100),
        lockRate: Math.round((stats.liquidityLocked / stats.totalCoins) * 100),
        generatedAt: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('‚ùå Error generating Rugcheck stats:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to generate Rugcheck statistics',
      details: error.message
    });
  }
});

// Rugcheck liquidity lock verification endpoint
app.get('/api/rugcheck/:mintAddress', async (req, res) => {
  try {
    const { mintAddress } = req.params;
    
    console.log(`üîç Rugcheck verification requested for: ${mintAddress}`);
    
    const rugcheckData = await rugcheckService.checkToken(mintAddress);
    
    if (!rugcheckData || !rugcheckData.rugcheckAvailable) {
      return res.status(404).json({
        success: false,
        error: 'Token not found or Rugcheck API unavailable',
        mintAddress,
        fallbackUsed: true
      });
    }

    res.json({
      success: true,
      data: {
        mintAddress,
        liquidityLocked: rugcheckData.liquidityLocked,
        lockPercentage: rugcheckData.lockPercentage,
        burnPercentage: rugcheckData.burnPercentage,
        riskLevel: rugcheckData.riskLevel,
        score: rugcheckData.score,
        freezeAuthority: rugcheckData.freezeAuthority,
        mintAuthority: rugcheckData.mintAuthority,
        topHolderPercent: rugcheckData.topHolderPercent,
        isHoneypot: rugcheckData.isHoneypot,
        verified: rugcheckData.rugcheckAvailable
      },
      metadata: {
        source: 'Rugcheck.xyz',
        checkedAt: new Date().toISOString()
      }
    });
    
  } catch (error) {
    console.error('‚ùå Error fetching Rugcheck data:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch Rugcheck verification',
      details: error.message,
      mintAddress: req.params.mintAddress
    });
  }
});

// Rugcheck verification for ALL current coins
app.post('/api/rugcheck/verify-all', async (req, res) => {
  try {
    if (currentCoins.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'No coins currently loaded'
      });
    }

    console.log(`üîç Starting Rugcheck verification for ALL ${currentCoins.length} current coins...`);
    
    // Re-enrich current coins with Rugcheck data
    const rugcheckEnrichedCoins = await enrichCoinsWithRugcheck(currentCoins);
    
    // Update the current coins with new Rugcheck data
    currentCoins = rugcheckEnrichedCoins;
    
    // Generate statistics
    const stats = {
      totalCoins: rugcheckEnrichedCoins.length,
      rugcheckVerified: rugcheckEnrichedCoins.filter(coin => coin.rugcheckVerified).length,
      liquidityLocked: rugcheckEnrichedCoins.filter(coin => coin.liquidityLocked).length,
      highRisk: rugcheckEnrichedCoins.filter(coin => coin.riskLevel === 'high').length,
      mediumRisk: rugcheckEnrichedCoins.filter(coin => coin.riskLevel === 'medium').length,
      lowRisk: rugcheckEnrichedCoins.filter(coin => coin.riskLevel === 'low').length,
      honeypots: rugcheckEnrichedCoins.filter(coin => coin.isHoneypot).length
    };

    // Sample of verified coins with locked liquidity
    const sampleLockedCoins = rugcheckEnrichedCoins
      .filter(coin => coin.liquidityLocked && coin.rugcheckVerified)
      .slice(0, 5)
      .map(coin => ({
        symbol: coin.symbol,
        name: coin.name,
        mintAddress: coin.mintAddress,
        lockPercentage: coin.lockPercentage,
        burnPercentage: coin.burnPercentage,
        riskLevel: coin.rugcheckScore,
        score: coin.rugcheckScore
      }));

    console.log(`‚úÖ Rugcheck verification complete for all coins`);
    console.log(`üîí ${stats.liquidityLocked}/${stats.totalCoins} coins have locked liquidity`);
    console.log(`‚úÖ ${stats.rugcheckVerified}/${stats.totalCoins} coins verified by Rugcheck`);

    res.json({
      success: true,
      message: `Rugcheck verification completed for all ${stats.totalCoins} coins`,
      stats,
      sampleLockedCoins,
      metadata: {
        verificationRate: Math.round((stats.rugcheckVerified / stats.totalCoins) * 100),
        lockRate: Math.round((stats.liquidityLocked / stats.totalCoins) * 100),
        source: 'Rugcheck.xyz',
        completedAt: new Date().toISOString()
      }
    });
    
  } catch (error) {
    console.error('‚ùå Error in verify-all endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to verify all coins with Rugcheck',
      details: error.message
    });
  }
});

// Progressive Rugcheck verification - processes ALL coins in batches of 30
app.post('/api/rugcheck/verify-all-progressive', async (req, res) => {
  try {
    const { startIndex = 0, batchSize = 30 } = req.body;
    
    if (currentCoins.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'No coins loaded to verify'
      });
    }



    const totalCoins = currentCoins.length;
    const remainingCoins = totalCoins - startIndex;
    const coinsToProcess = Math.min(batchSize, remainingCoins);
    
    if (startIndex >= totalCoins) {
      return res.json({
        success: true,
        message: 'All coins have been processed',
        progress: {
          processed: totalCoins,
          total: totalCoins,
          percentage: 100,
          completed: true
        }
     
      });
    }

    console.log(`üîç Progressive Rugcheck: Processing batch starting at index ${startIndex} (${coinsToProcess} coins)`);
    
    // Get the batch of coins to process
    const batchToProcess = currentCoins.slice(startIndex, startIndex + coinsToProcess);
    const mintAddresses = batchToProcess.map(coin => 
      coin.mintAddress || coin.tokenAddress || coin.address
    ).filter(Boolean);

    // Process this batch
    const rugcheckResults = await rugcheckService.checkMultipleTokens(mintAddresses, {
      maxConcurrent: 2,
      batchDelay: 1500,
      maxTokens: coinsToProcess
    });

    // Update the coins in currentCoins with Rugcheck data
    let updatedCount = 0;
    for (let i = 0; i < batchToProcess.length; i++) {
      const coinIndex = startIndex + i;
      const coin = currentCoins[coinIndex];
      const mintAddress = coin.mintAddress || coin.tokenAddress || coin.address;
      const rugcheckData = rugcheckResults.find(r => r.address === mintAddress);
      
      if (rugcheckData && rugcheckData.rugcheckAvailable) {
        currentCoins[coinIndex] = {
          ...coin,
          liquidityLocked: rugcheckData.liquidityLocked,
          lockPercentage: rugcheckData.lockPercentage,
          burnPercentage: rugcheckData.burnPercentage,
          rugcheckScore: rugcheckData.score,
          riskLevel: rugcheckData.riskLevel,
          freezeAuthority: rugcheckData.freezeAuthority,
          mintAuthority: rugcheckData.mintAuthority,
          topHolderPercent: rugcheckData.topHolderPercent,
          isHoneypot: rugcheckData.isHoneypot,
          rugcheckVerified: true,
          rugcheckProcessedAt: new Date().toISOString()
        };
        updatedCount++;
      } else {
        // Mark as processed but not verified
        currentCoins[coinIndex] = {
          ...coin,
          rugcheckVerified: false,
          rugcheckProcessedAt: new Date().toISOString()
        };
      }
    }

    // Calculate overall progress
    const processedSoFar = startIndex + coinsToProcess;
    const progressPercentage = Math.round((processedSoFar / totalCoins) * 100);
    const verifiedCount = rugcheckResults.filter(r => r.rugcheckAvailable).length;
    const lockedCount = rugcheckResults.filter(r => r.liquidityLocked).length;
    
    
    // Calculate next batch info
    const nextIndex = processedSoFar;
    const hasMore = nextIndex < totalCoins;
    const remainingAfterThis = totalCoins - processedSoFar;

    console.log(`‚úÖ Batch complete: ${verifiedCount}/${coinsToProcess} verified, ${lockedCount} locked. Progress: ${progressPercentage}%`);

    res.json({
      success: true,
      message: `Processed batch ${Math.ceil(processedSoFar / batchSize)} of ${Math.ceil(totalCoins / batchSize)}`,
      batch: {
        startIndex,
        processed: coinsToProcess,
        verified: verifiedCount,
        locked: lockedCount,
        updated: updatedCount
      },
      progress: {
        processed: processedSoFar,
        total: totalCoins,
        percentage: progressPercentage,
        completed: !hasMore
      },
      next: hasMore ? {
        startIndex: nextIndex,
        remaining: remainingAfterThis,
        estimatedBatches: Math.ceil(remainingAfterThis / batchSize)
      } : null,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in progressive Rugcheck verification:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to perform progressive Rugcheck verification',
      details: error.message
    });
  }
});

// Fetch fresh coins for "new" tab from Solana Tracker
async function fetchNewTabCoins() {
  const searchParams = {
    minVolume: 15000,           // $15k minimum volume
    maxVolume: 30000,           // $30k maximum volume
    volumeTimeframe: "24h",     // 24 hour timeframe
    maxAge: 96,                 // Maximum age of 96 hours (4 days)
    page: 1
  };

  console.log(`üÜï NEW TAB - Fetching coins with $15k-$30k volume, max 96h age`);
  const response = await makeSolanaTrackerRequest('/search', searchParams);
  
  if (response.status !== 'success' || !response.data) {
    throw new Error('Invalid response from Solana Tracker');
  }

  const tokens = response.data;
  console.log(`üÜï Got ${tokens.length} "new" tokens from Solana Tracker`);

  // Filter for coins with socials AND banners
  const filteredTokens = tokens.filter(token => {
    const hasSocials = token.twitter || token.telegram || token.website || token.discord;
    const hasBanner = token.banner || token.header;
    return hasSocials && hasBanner;
  });

  console.log(`üÜï Filtered to ${filteredTokens.length} tokens with socials and banners`);

  // Format tokens for frontend
  const formattedTokens = filteredTokens.map((token, index) => ({
    mintAddress: token.mint,
    name: token.name || 'Unknown',
    symbol: token.symbol || 'UNKNOWN',
    image: token.image || `https://via.placeholder.com/64/00d4ff/ffffff?text=${(token.symbol || 'T').charAt(0)}`,
    profileImage: token.image || `https://via.placeholder.com/64/00d4ff/ffffff?text=${(token.symbol || 'T').charAt(0)}`,
    logo: token.image || `https://via.placeholder.com/64/00d4ff/ffffff?text=${(token.symbol || 'T').charAt(0)}`,
    banner: token.banner || token.header || '',
    price_usd: token.priceUsd || 0,
    market_cap_usd: token.marketCapUsd || 0,
    volume_24h_usd: token.volume_24h || 0,
    liquidity: token.liquidity || 0,
    liquidity_usd: token.liquidityUsd || token.liquidity || 0,
    age: token.age || 0,
    created_timestamp: token.createdAt ? new Date(token.createdAt).getTime() : Date.now(),
    description: token.description || '',
    // Social links
    socialLinks: {
      twitter: token.twitter || '',
      telegram: token.telegram || '',
      website: token.website || '',
      discord: token.discord || ''
    },
    socials: {
      twitter: token.twitter || '',
      telegram: token.telegram || '',
      website: token.website || '',
      discord: token.discord || ''
    },
    // Additional fields
    buys_24h: token.buys_24h || 0,
    sells_24h: token.sells_24h || 0,
    transactions_24h: (token.buys_24h || 0) + (token.sells_24h || 0),
    priority: index + 1
  }));
  
  // Apply priority scoring
  const coinsWithPriority = rugcheckService.sortCoinsByPriority(formattedTokens);

  console.log(`üÜï Final "new" tab result: ${coinsWithPriority.length} coins after priority sorting`);
  
  return coinsWithPriority;
}

// Check if new tab cache needs refresh
function shouldRefreshNewTab() {
  if (!newTabLastFetch) return true;
  const timeSinceLastFetch = Date.now() - newTabLastFetch;
  return timeSinceLastFetch >= NEW_TAB_REFRESH_INTERVAL;
}

// Auto-refresh new tab data every 30 minutes
async function autoRefreshNewTab() {
  if (shouldRefreshNewTab()) {
    try {
      console.log('üîÑ Auto-refreshing "new" tab data...');
      newTabCoins = await fetchNewTabCoins();
      newTabLastFetch = Date.now();
      console.log(`‚úÖ "New" tab refreshed: ${newTabCoins.length} coins`);
    } catch (error) {
      console.error('‚ùå Failed to auto-refresh "new" tab:', error.message);
    }
  }
}

// Start auto-refresh interval for new tab (check every 5 minutes)
setInterval(autoRefreshNewTab, 5 * 60 * 1000);

// "New" tab endpoint - shows coins with $15k-$30k volume, max 96h age, with socials and banners
app.get('/api/coins/new', async (req, res) => {
  try {
    console.log('üÜï /api/coins/new endpoint called');
    
    const limit = parseInt(req.query.limit) || 50;
    const forceRefresh = req.query.refresh === 'true';
    
    // Fetch if cache is empty, expired, or force refresh requested
    if (newTabCoins.length === 0 || shouldRefreshNewTab() || forceRefresh) {
      console.log('üîÑ Fetching fresh "new" tab data...');
      try {
        newTabCoins = await fetchNewTabCoins();
        newTabLastFetch = Date.now();
      } catch (error) {
        console.error('‚ùå Failed to fetch "new" tab coins:', error.message);
        if (newTabCoins.length === 0) {
          return res.status(500).json({
            success: false,
            error: 'Failed to fetch new coins',
            details: error.message
          });
        }
        // Use stale cache if available
        console.log('‚ö†Ô∏è Using stale cache for "new" tab');
      }
    }
    
    // Merge Jupiter Live Prices
    let coinsWithPrices = [...newTabCoins];
    if (jupiterLivePriceService && jupiterLivePriceService.isRunning) {
      coinsWithPrices = coinsWithPrices.map(coin => {
        const address = coin.mintAddress || coin.address;
        if (address) {
          const livePrice = jupiterLivePriceService.getPrice(address);
          if (livePrice && livePrice.price > 0) {
            return {
              ...coin,
              price: livePrice.price,
              currentPrice: livePrice.price,
              priceSource: 'jupiter-live',
              priceTimestamp: livePrice.timestamp,
              priceChange: livePrice.priceChangeInstant || 0,
              lastJupiterUpdate: livePrice.timestamp
            };
          }
        }
        return coin;
      });
    }
    
    const paginatedCoins = coinsWithPrices.slice(0, limit);
    const nextRefreshIn = newTabLastFetch 
      ? Math.max(0, NEW_TAB_REFRESH_INTERVAL - (Date.now() - newTabLastFetch))
      : 0;
    
    res.json({
      success: true,
      coins: paginatedCoins,
      count: paginatedCoins.length,
      total: newTabCoins.length,
      data_source: 'solana-tracker-new',
      last_refresh: newTabLastFetch ? new Date(newTabLastFetch).toISOString() : null,
      next_refresh_in_ms: nextRefreshIn,
      next_refresh_in_minutes: Math.ceil(nextRefreshIn / 60000),
      filters: {
        volume: '$15k-$30k',
        max_age: '96 hours',
        required: ['socials', 'banner']
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in new tab endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch new tokens',
      details: error.message
    });
  }
});

// Latest coins (sort by age/creation time)
app.get('/api/coins/solana-latest', (req, res) => {
  try {
    console.log('üÜï /api/coins/solana-latest endpoint called');
    
    const limit = parseInt(req.query.limit) || currentCoins.length;
    
    // Filter for newer coins (less than 7 days old) then apply priority sorting
    const recentCoins = currentCoins.filter(coin => (coin.age || 0) < 168); // 168 hours = 7 days
    const coins = rugcheckService.sortCoinsByPriority(recentCoins)
      .slice(0, limit);
    
    console.log(`üÜï First recent coin after priority sorting: ${coins[0]?.symbol} (Age: ${coins[0]?.age}h, Score: ${coins[0]?.priorityScore?.score?.toFixed(1)})`);
    
    res.json({
      success: true,
      coins: coins,
      count: coins.length,
      total: currentCoins.length,
      timestamp: new Date().toISOString(),
      source: 'batch-storage-latest'
    });
    
  } catch (error) {
    console.error('‚ùå Error in latest endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch latest tokens',
      details: error.message
    });
  }
});

// Fast coins endpoint - serves raw data immediately (no enrichment)
app.get('/api/coins/fast', (req, res) => {
  try {
    console.log('‚ö° /api/coins/fast endpoint called (priceEngine-optimized)');
    
    const limit = parseInt(req.query.limit) || 50;
    
    let sourceCoins = [];
    let dataSource = 'unknown';
    
    // Try to get fast data from priceEngine first
    if (global.priceEngine) {
      try {
        const liveData = global.priceEngine.getPricesData();
        if (liveData && liveData.length > 0) {
          sourceCoins = liveData;
          dataSource = 'priceEngine-fast';
          console.log(`‚ö° Using ${liveData.length} coins from priceEngine for fast response`);
        } else {
          sourceCoins = currentCoins;
          dataSource = 'cache-fast';
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è PriceEngine error in fast endpoint, using cache:', error.message);
        sourceCoins = currentCoins;
        dataSource = 'cache-fallback';
      }
    } else {
      sourceCoins = currentCoins;
      dataSource = 'cache-only';
    }
    
    if (!sourceCoins || sourceCoins.length === 0) {
      return res.json({
        success: true,
        coins: [],
        count: 0,
        total: 0,
        message: 'No coins available in cache',
        timestamp: new Date().toISOString(),
        source: dataSource
      });
    }
    
    // Merge Jupiter Live Prices into fast coin data
    if (sourceCoins.length > 0 && jupiterLivePriceService && jupiterLivePriceService.isRunning) {
      console.log('ü™ê Merging Jupiter live prices into fast endpoint...');
      let jupiterPriceUpdates = 0;
      
      sourceCoins = sourceCoins.map(coin => {
        const address = coin.mintAddress || coin.address || coin.tokenAddress;
        if (address) {
          const livePrice = jupiterLivePriceService.getPrice(address);
          if (livePrice && livePrice.price > 0) {
            // Update coin with live Jupiter price
            const updatedCoin = {
              ...coin,
              price: livePrice.price,
              currentPrice: livePrice.price,
              priceSource: 'jupiter-live',
              priceTimestamp: livePrice.timestamp,
              priceChange: livePrice.priceChangeInstant || 0,
              lastJupiterUpdate: livePrice.timestamp
            };
            jupiterPriceUpdates++;
            return updatedCoin;
          }
        }
        return coin;
      });
      
      console.log(`ü™ê Updated ${jupiterPriceUpdates} coins with Jupiter live prices in fast endpoint`);
      if (jupiterPriceUpdates > 0) {
        dataSource += '-jupiter-enhanced';
      }
    }
    
    // Serve coins with live data when available
    const fastCoins = sourceCoins.slice(0, limit).map(coin => ({
      // Essential data for immediate UI display
      mintAddress: coin.mintAddress || coin.address,
      address: coin.mintAddress || coin.address,
      symbol: coin.symbol,
      name: coin.name,
      image: coin.image || coin.profileImage || coin.logo,
      
      // Market data - prioritize live data from priceEngine
      price_usd: coin.currentPrice || coin.price_usd || coin.priceUsd || coin.price || 0,
      market_cap_usd: coin.marketCap || coin.market_cap_usd || coin.marketCap || 0,
      liquidity_usd: coin.liquidity || coin.liquidity_usd || coin.liquidity?.usd || 0,
      volume_24h_usd: coin.volume24h || coin.volume_24h_usd || coin.volume24h || coin.volume || 0,
      
      // Price changes - use live data when available
      priceChange24h: coin.priceChangePercent || coin.priceChange24h || 0,
      priceChange1h: coin.priceChange1h || 0,
      priceChange5m: coin.priceChange5m || 0,
      
      // Transaction data
      buys_24h: coin.buys_24h || 0,
      sells_24h: coin.sells_24h || 0,
      transactions_24h: coin.transactions_24h || (coin.buys_24h || 0) + (coin.sells_24h || 0),
      
      // Basic metadata
      created_timestamp: coin.created_timestamp,
      createdAt: coin.createdAt,
      description: coin.description || '',
      website: coin.website,
      twitter: coin.twitter,
      telegram: coin.telegram,
      
      // Flags
      isScam: coin.isScam || false,
      isPumpFun: coin.isPumpFun || false,
      
      // Source tracking
      source: dataSource,
      enriched: !!coin.currentPrice, // Mark as enriched if it has live price data
      hasLiveData: !!coin.currentPrice,
      lastUpdated: coin.lastUpdated || new Date().toISOString()
    }));
    
    const liveDataCount = fastCoins.filter(coin => coin.hasLiveData).length;
    
    res.json({
      success: true,
      coins: fastCoins,
      count: fastCoins.length,
      total: sourceCoins.length,
      live_data_count: liveDataCount,
      live_data_rate: fastCoins.length > 0 ? `${((liveDataCount / fastCoins.length) * 100).toFixed(1)}%` : '0%',
      message: 'Optimized coin data with live prices when available',
      data_source: dataSource,
      enrichment: {
        status: liveDataCount > 0 ? 'partial' : 'pending',
        note: 'Use /api/coins/enrich endpoint to get enriched data with banners and security analysis'
      },
      timestamp: new Date().toISOString(),
      source: dataSource
    });
    
  } catch (error) {
    console.error('‚ùå Error in fast endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to serve fast coin data',
      details: error.message
    });
  }
});

// "New" tab endpoint - shows coins with $15k-$30k volume, max 96h age, with socials and banners
app.get('/api/coins/new', async (req, res) => {
  try {
    console.log('üÜï /api/coins/new endpoint called');
    
    const limit = parseInt(req.query.limit) || 50;
    const forceRefresh = req.query.refresh === 'true';
    
    // Fetch if cache is empty, expired, or force refresh requested
    if (newTabCoins.length === 0 || shouldRefreshNewTab() || forceRefresh) {
      console.log('üîÑ Fetching fresh "new" tab data...');
      try {
        newTabCoins = await fetchNewTabCoins();
        newTabLastFetch = Date.now();
      } catch (error) {
        console.error('‚ùå Failed to fetch "new" tab coins:', error.message);
        if (newTabCoins.length === 0) {
          return res.status(500).json({
            success: false,
            error: 'Failed to fetch new coins',
            details: error.message
          });
        }
        // Use stale cache if available
        console.log('‚ö†Ô∏è Using stale cache for "new" tab');
      }
    }
    
    // Merge Jupiter Live Prices
    let coinsWithPrices = [...newTabCoins];
    if (jupiterLivePriceService && jupiterLivePriceService.isRunning) {
      coinsWithPrices = coinsWithPrices.map(coin => {
        const address = coin.mintAddress || coin.address;
        if (address) {
          const livePrice = jupiterLivePriceService.getPrice(address);
          if (livePrice && livePrice.price > 0) {
            return {
              ...coin,
              price: livePrice.price,
              currentPrice: livePrice.price,
              priceSource: 'jupiter-live',
              priceTimestamp: livePrice.timestamp,
              priceChange: livePrice.priceChangeInstant || 0,
              lastJupiterUpdate: livePrice.timestamp
            };
          }
        }
        return coin;
      });
    }
    
    const paginatedCoins = coinsWithPrices.slice(0, limit);
    const nextRefreshIn = newTabLastFetch 
      ? Math.max(0, NEW_TAB_REFRESH_INTERVAL - (Date.now() - newTabLastFetch))
      : 0;
    
    res.json({
      success: true,
      coins: paginatedCoins,
      count: paginatedCoins.length,
      total: newTabCoins.length,
      data_source: 'solana-tracker-new',
      last_refresh: newTabLastFetch ? new Date(newTabLastFetch).toISOString() : null,
      next_refresh_in_ms: nextRefreshIn,
      next_refresh_in_minutes: Math.ceil(nextRefreshIn / 60000),
      filters: {
        volume: '$15k-$30k',
        max_age: '96 hours',
        required: ['socials', 'banner']
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in new tab endpoint:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch new tokens',
      details: error.message
    });
  }
});
