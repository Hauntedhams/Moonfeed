<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Price Chart Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .chart-container {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            margin: 20px 0;
        }
        .timeframe-selector {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        .timeframe-btn {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
        }
        .timeframe-btn.active {
            background: #007bff;
            color: white;
        }
        .info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>Price History Chart Test</h1>
    
    <div class="info">
        <h3>Token: HEDGEMONY</h3>
        <p>Address: KounQV6YhTgWFHbs4wNjyRp2VoY4ghoysveNQeGuBLV</p>
        <p>Testing realistic price interpolation from Dexscreener data</p>
    </div>

    <div class="timeframe-selector">
        <button class="timeframe-btn" onclick="setTimeframe('1m')">1M</button>
        <button class="timeframe-btn" onclick="setTimeframe('15m')">15M</button>
        <button class="timeframe-btn" onclick="setTimeframe('1h')">1H</button>
        <button class="timeframe-btn" onclick="setTimeframe('4h')">4H</button>
        <button class="timeframe-btn active" onclick="setTimeframe('24h')">24H</button>
    </div>

    <div class="chart-container">
        <canvas id="priceChart" width="100%" height="400"></canvas>
    </div>

    <div id="status">Loading chart data...</div>
    <div id="chartInfo"></div>

    <script>
        let currentTimeframe = '24h';
        const tokenAddress = 'KounQV6YhTgWFHbs4wNjyRp2VoY4ghoysveNQeGuBLV';

        function setTimeframe(timeframe) {
            currentTimeframe = timeframe;
            
            // Update button states
            document.querySelectorAll('.timeframe-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            loadChartData();
        }

        async function loadChartData() {
            const statusEl = document.getElementById('status');
            const chartInfoEl = document.getElementById('chartInfo');
            
            statusEl.textContent = `Loading ${currentTimeframe} chart data...`;
            chartInfoEl.innerHTML = '';

            try {
                const response = await fetch(`http://localhost:3001/api/chart/${tokenAddress}?timeframe=${currentTimeframe}`);
                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.error || 'Failed to fetch chart data');
                }

                statusEl.textContent = `✅ Loaded ${data.data.dataPoints.length} data points`;
                chartInfoEl.innerHTML = `
                    <div class="info">
                        <h4>Chart Data (${currentTimeframe.toUpperCase()})</h4>
                        <p><strong>Current Price:</strong> $${data.data.current}</p>
                        <p><strong>24h Change:</strong> ${data.data.change24h > 0 ? '+' : ''}${data.data.change24h}%</p>
                        <p><strong>Data Points:</strong> ${data.data.dataPoints.length}</p>
                        <p><strong>Data Quality:</strong> ${data.data.dataQuality.description}</p>
                        <p><strong>Time Range:</strong> ${new Date(data.data.dataPoints[0].time).toLocaleString()} → ${new Date(data.data.dataPoints[data.data.dataPoints.length - 1].time).toLocaleString()}</p>
                    </div>
                `;

                drawChart(data.data.dataPoints, data.data);

            } catch (error) {
                statusEl.textContent = `❌ Error: ${error.message}`;
                console.error('Chart loading error:', error);
            }
        }

        function drawChart(dataPoints, chartData) {
            const canvas = document.getElementById('priceChart');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!dataPoints || dataPoints.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Calculate dimensions
            const padding = 40;
            const chartWidth = canvas.width - padding * 2;
            const chartHeight = canvas.height - padding * 2;

            // Find min/max for scaling
            const prices = dataPoints.map(d => d.price);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice || 0.0001;

            // Determine color based on trend
            const isPositive = prices[prices.length - 1] > prices[0];
            const color = isPositive ? '#10b981' : '#ef4444';

            // Create gradient
            const gradient = ctx.createLinearGradient(0, padding, 0, canvas.height - padding);
            gradient.addColorStop(0, color + '40');
            gradient.addColorStop(1, color + '00');

            // Build path points
            const points = dataPoints.map((point, index) => {
                const x = padding + (index / (dataPoints.length - 1)) * chartWidth;
                const y = padding + (1 - (point.price - minPrice) / priceRange) * chartHeight;
                return { x, y, price: point.price, time: point.time };
            });

            // Draw filled area
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.lineTo(points[points.length - 1].x, canvas.height - padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Draw line
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw price labels
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            
            // Min price
            ctx.fillText('$' + minPrice.toFixed(6), padding - 5, canvas.height - padding + 4);
            
            // Max price
            ctx.fillText('$' + maxPrice.toFixed(6), padding - 5, padding + 4);

            // Current price
            const currentY = padding + (1 - (chartData.current - minPrice) / priceRange) * chartHeight;
            ctx.fillStyle = color;
            ctx.fillText('$' + chartData.current.toFixed(6), padding - 5, currentY + 4);
        }

        // Load initial chart
        loadChartData();
    </script>
</body>
</html>
