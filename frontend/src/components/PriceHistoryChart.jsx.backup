import React, { useEffect, useRef, useState } from 'react';
import './PriceHistoryChart.css';

const PriceHistoryChart = ({ coin, width, height = 200 }) => {
  // Use parent container width - if width is "100%" or similar, use full container
  const chartWidth = width === "100%" ? "100%" : (width || 280);
  const canvasRef = useRef(null);
  const [chartData, setChartData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [hoveredPoint, setHoveredPoint] = useState(null); // For tooltip
  
  // Diagnostic timing
  const mountTimeRef = useRef(Date.now());
  const lastFetchTimeRef = useRef(null);
  const drawTimeRef = useRef(null);

  // Remove timeframe selector - always show 24H blended view
  // const timeframes = ['1M', '15M', '1H', '4H', '24H'];

  // Helper functions for tooltip
  const formatPrice = (price) => {
    if (price < 0.01) return `$${price.toFixed(6)}`;
    if (price < 1) return `$${price.toFixed(4)}`;
    return `$${price.toFixed(2)}`;
  };

  const formatTime = (timestamp) => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };

  // Handle canvas mouse events for tooltip
  const handleCanvasMouseMove = (event) => {
    if (!chartData?.dataPoints || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    // Find closest data point
    const containerWidth = canvas.parentElement?.offsetWidth || (typeof chartWidth === 'number' ? chartWidth : 280);
    const containerHeight = height;
    const padding = { top: 5, right: 0, bottom: 5, left: 0 };
    const chartWidthCalc = containerWidth;
    
    const pointIndex = Math.round((mouseX / chartWidthCalc) * (chartData.dataPoints.length - 1));
    const clampedIndex = Math.max(0, Math.min(pointIndex, chartData.dataPoints.length - 1));
    
    if (chartData.dataPoints[clampedIndex]) {
      const dataPoint = chartData.dataPoints[clampedIndex];
      setHoveredPoint({
        x: mouseX,
        y: mouseY,
        price: dataPoint.price,
        time: dataPoint.timestamp,
        index: clampedIndex
      });
    }
  };

  const handleCanvasMouseLeave = () => {
    setHoveredPoint(null);
  };

  useEffect(() => {
    console.log('ÔøΩ [24H CHART] Component mounted, generating blended 24-hour chart');
    console.log('ÔøΩ [24H CHART] Coin data:', {
      symbol: coin?.symbol,
      hasPriceChanges: !!(coin?.priceChanges || coin?.priceChange),
      currentPrice: coin?.price_usd || coin?.priceUsd
    });
    
    return () => {
      const totalTime = Date.now() - mountTimeRef.current;
      console.log('ÔøΩ [24H CHART] Component unmounted after', totalTime, 'ms');
    };
  }, []);

  // Map frontend timeframes to backend timeframes
  const getBackendTimeframe = (frontendTimeframe) => {
    const mapping = {
      '1M': '1m',
      '15M': '15m', 
      '1H': '1h',
      '4H': '4h',
      '24H': '24h'
    };
    return mapping[frontendTimeframe] || '1h';
  };

  useEffect(() => {
    console.log('ÔøΩ [24H CHART] Dependency changed - regenerating chart');
    
    if (coin) {
      // Generate blended 24-hour chart from all available DexScreener price changes
      generateBlended24HourChart();
    } else {
      console.log('‚ùå [24H CHART] No coin data available');
      setError('No coin data available');
      setLoading(false);
    }
  }, [coin?.mintAddress || coin?.tokenAddress]);

  // Draw chart immediately when data is ready
  useEffect(() => {
    console.log('üîç [CHART DIAGNOSTIC] Chart data effect triggered:', {
      hasChartData: !!chartData,
      hasDataPoints: !!(chartData?.dataPoints),
      dataPointsLength: chartData?.dataPoints?.length || 0
    });
    
    if (chartData && chartData.dataPoints && chartData.dataPoints.length > 0) {
      drawTimeRef.current = Date.now();
      drawChart(chartData.dataPoints);
      const drawDuration = Date.now() - drawTimeRef.current;
      console.log('üîç [CHART DIAGNOSTIC] Chart drawn in', drawDuration, 'ms');
    }
  }, [chartData]);

  // Generate chart from DexScreener price change data (no API call)
  const generateChartFromPriceChanges = () => {
    const generateStartTime = Date.now();
    console.log('ÔøΩ [CHART GENERATION] Starting chart generation from DexScreener data');
    
    setLoading(true);
    setError(null);
    
    try {
      const currentPrice = coin?.price_usd ?? coin?.priceUsd ?? coin?.price ?? 0;
      
      if (!currentPrice || currentPrice === 0) {
        throw new Error('No valid price data');
      }
      
      // Get price change for selected timeframe from DexScreener data
      const priceChange = getPriceChangeForTimeframe(selectedTimeframe);
      
      console.log('ÔøΩ [CHART GENERATION] Using price data:', {
        currentPrice,
        priceChange,
        timeframe: selectedTimeframe
      });
      
      // Generate smooth price history based on price change
      const dataPoints = generateSmoothPriceData(currentPrice, priceChange, selectedTimeframe);
      
      // Calculate min/max for chart display
      const prices = dataPoints.map(d => d.price);
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);
      
      setChartData({
        tokenInfo: {
          address: coin.mintAddress || coin.tokenAddress,
          minPrice,
          maxPrice,
          priceChange
        },
        dataPoints,
        metadata: {
          timeframe: selectedTimeframe,
          dataPoints: dataPoints.length,
          source: 'DexScreener price changes'
        }
      });
      
      const totalDuration = Date.now() - generateStartTime;
      console.log(`‚úÖ [CHART GENERATION] Generated ${dataPoints.length} points in ${totalDuration}ms`);
      
    } catch (error) {
      console.error('‚ùå [CHART GENERATION] Generation failed:', error);
      setError('Unable to generate chart');
    } finally {
      setLoading(false);
    }
  };
  
  // Get price change percentage for timeframe from DexScreener data
  const getPriceChangeForTimeframe = (timeframe) => {
    const priceChanges = coin?.priceChanges || coin?.priceChange || {};
    
    switch(timeframe) {
      case '1M':
        return priceChanges.change5m || priceChanges.m5 || coin?.change_5m || 0;
      case '15M':
        return priceChanges.change15m || priceChanges.m15 || coin?.change_15m || (priceChanges.change1h || priceChanges.h1 || 0) * 0.25;
      case '1H':
        return priceChanges.change1h || priceChanges.h1 || coin?.change_1h || 0;
      case '4H':
        return priceChanges.change4h || priceChanges.h4 || coin?.change_4h || (priceChanges.change6h || priceChanges.h6 || 0) * 0.67;
      case '24H':
        return priceChanges.change24h || priceChanges.h24 || coin?.change_24h || coin?.change24h || 0;
      default:
        return priceChanges.change1h || priceChanges.h1 || coin?.change_1h || 0;
    }
  };
  
  // Generate smooth price data from current price and price change percentage
  const generateSmoothPriceData = (currentPrice, priceChangePercent, timeframe) => {
    const numPoints = 60; // 60 data points for smooth chart
    const data = [];
    
    // Create deterministic seed from coin data for consistent charts
    const coinId = (coin?.mintAddress || coin?.tokenAddress || coin?.symbol || 'unknown');
    const coinSeed = coinId.split('').reduce((acc, char, i) => acc + char.charCodeAt(0) * (i + 1), 0);
    const timeframeSeed = timeframe.split('').reduce((acc, char, i) => acc + char.charCodeAt(0) * (i + 1), 0);
    const baseSeed = (coinSeed * 1000 + timeframeSeed) % 233280;
    
    // Seeded random for consistent results
    let seed = baseSeed;
    const seededRandom = () => {
      seed = (seed * 9301 + 49297) % 233280;
      return seed / 233280;
    };
    
    // Calculate start price from price change
    const changeDecimal = priceChangePercent / 100;
    const startPrice = currentPrice / (1 + changeDecimal);
    
    // Volatility based on price change magnitude
    const volatility = Math.max(0.005, Math.abs(changeDecimal) * 0.25);
    
    // Generate price points with smooth trend
    const priceMovements = [];
    let currentPricePoint = startPrice;
    
    for (let i = 0; i < numPoints; i++) {
      const progress = i / (numPoints - 1);
      
      // Trend towards final price (80% trend, 20% noise)
      const trendWeight = 0.8;
      const targetPrice = startPrice + (currentPrice - startPrice) * progress;
      
      // Add wave patterns for realistic movement
      const waveFrequency = 2 + (seededRandom() * 2);
      const wave1 = Math.sin(progress * Math.PI * waveFrequency) * volatility * startPrice * 0.2;
      const wave2 = Math.sin(progress * Math.PI * waveFrequency * 1.5) * volatility * startPrice * 0.1;
      
      // Random walk component
      const randomWalk = (seededRandom() - 0.5) * volatility * startPrice * 0.15;
      
      // Momentum (price continuation)
      const momentum = i > 0 ? (priceMovements[i-1] - (i > 1 ? priceMovements[i-2] : startPrice)) * 0.2 : 0;
      
      // Combine all factors
      let newPrice = targetPrice * trendWeight + 
                     currentPricePoint * (1 - trendWeight) + 
                     wave1 + wave2 + randomWalk + momentum;
      
      // Ensure price stays within reasonable bounds
      newPrice = Math.max(0.000001, newPrice);
      newPrice = Math.max(startPrice * 0.7, Math.min(startPrice * 1.5, newPrice));
      
      priceMovements.push(newPrice);
      currentPricePoint = newPrice;
      
      // Calculate timestamp based on timeframe
      const intervalMs = getIntervalForTimeframe(timeframe);
      const timestamp = Date.now() - (numPoints - i) * intervalMs;
      
      data.push({
        timestamp,
        price: newPrice,
        time: new Date(timestamp).toLocaleTimeString()
      });
    }
    
    return data;
  };
  
  // Get interval in milliseconds for each timeframe
  const getIntervalForTimeframe = (timeframe) => {
    const intervals = {
      '1M': 1 * 60 * 1000,        // 1 minute
      '15M': 15 * 60 * 1000,      // 15 minutes
      '1H': 60 * 60 * 1000,       // 1 hour
      '4H': 4 * 60 * 60 * 1000,   // 4 hours
      '24H': 24 * 60 * 60 * 1000  // 24 hours
    };
    return intervals[timeframe] || 60 * 60 * 1000;
  };

  const drawChart = (dataPoints) => {
    const drawStartTime = Date.now();
    console.log('üîç [CHART DIAGNOSTIC] Starting chart draw with', dataPoints.length, 'points');
    
    const canvas = canvasRef.current;
    if (!canvas || !dataPoints || dataPoints.length === 0) {
      console.log('‚ùå [CHART DIAGNOSTIC] Draw aborted - missing canvas or data');
      return;
    }

    const ctx = canvas.getContext('2d');
    
    // Use parent container width like CleanPriceChart does
    const containerWidth = canvas.parentElement?.offsetWidth || (typeof chartWidth === 'number' ? chartWidth : 280);
    const containerHeight = height;
    
    // Use device pixel ratio for HD rendering
    const dpr = window.devicePixelRatio || 1;
    
    console.log('üîç [CHART DIAGNOSTIC] Canvas dimensions:', {
      width: containerWidth,
      height: containerHeight,
      dpr: dpr,
      canvasElement: !!canvas
    });
    
    // Set canvas size for crisp HD rendering using container dimensions
    canvas.width = containerWidth * dpr;
    canvas.height = containerHeight * dpr;
    canvas.style.width = containerWidth + 'px';
    canvas.style.height = containerHeight + 'px';
    ctx.scale(dpr, dpr);

    // Debug: Log actual canvas and chart dimensions
    console.log('üìê [CHART DIMENSIONS]', {
      containerWidth: containerWidth,
      containerHeight: containerHeight,
      canvasWidth: canvas.width,
      canvasHeight: canvas.height,
      devicePixelRatio: dpr
    });

    // Clear canvas with white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, containerWidth, containerHeight);

    // Calculate dimensions - TRUE edge-to-edge, no padding at all
    const padding = { top: 5, right: 0, bottom: 5, left: 0 };
    const chartWidth = containerWidth; // Use full container width
    const chartHeight = containerHeight - padding.top - padding.bottom;

    // Find min/max for scaling with slight padding
    const prices = dataPoints.map(d => d.price);
    const minPrice = Math.min(...prices) * 0.98; // 2% padding
    const maxPrice = Math.max(...prices) * 1.02; // 2% padding
    const priceRange = maxPrice - minPrice || 0.0001;

    console.log('üîç [CHART DIAGNOSTIC] Price range:', {
      min: minPrice,
      max: maxPrice,
      range: priceRange
    });

    // Determine color based on trend
    const isPositive = prices[prices.length - 1] > prices[0];
    const lineColor = isPositive ? '#22c55e' : '#ef4444';

    // Build path points - TRUE edge-to-edge positioning
    const points = dataPoints.map((point, index) => {
      const x = (index / (dataPoints.length - 1)) * chartWidth; // Start from 0, end at chartWidth
      const y = padding.top + (1 - (point.price - minPrice) / priceRange) * chartHeight;
      return { x, y };
    });

    // Debug: Log actual drawing coordinates
    console.log('üìç [CHART COORDINATES]', {
      chartWidth,
      chartHeight, 
      padding,
      firstPoint: points[0],
      lastPoint: points[points.length - 1],
      totalPoints: points.length
    });

    // Draw smooth line with better quality
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    
    // Use smooth curves for better appearance
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 2.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.stroke();
    
    const drawDuration = Date.now() - drawStartTime;
    console.log('üîç [CHART DIAGNOSTIC] Chart drawing completed in', drawDuration, 'ms');
  };

  if (error) {
    return (
      <div className="price-history-chart error">
        <div className="error-message">
          <div className="error-text">
            <h3>Chart Unavailable</h3>
            <p>{error}</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="price-history-chart">
      {/* Timeframe Selector */}
      <div className="timeframe-selector">
        {timeframes.map((timeframe) => (
          <button
            key={timeframe}
            className={`timeframe-btn ${selectedTimeframe === timeframe ? 'active' : ''}`}
            onClick={() => setSelectedTimeframe(timeframe)}
            disabled={false}
          >
            {timeframe}
          </button>
        ))}
      </div>

      {/* Chart Container */}
      <div className="chart-container">
        {loading ? (
          <div className="chart-loading">
            <div className="loading-spinner">‚ü≥</div>
            <span>Loading chart...</span>
          </div>
        ) : (
          <>
            <canvas 
              ref={canvasRef} 
              className="price-canvas"
              onMouseMove={handleCanvasMouseMove}
              onMouseLeave={handleCanvasMouseLeave}
            />
            
            {/* Tooltip */}
            {hoveredPoint && (
              <div 
                className="chart-tooltip"
                style={{
                  left: hoveredPoint.x > (canvasRef.current?.offsetWidth * 0.7 || 200) ? `${hoveredPoint.x - 140}px` : `${hoveredPoint.x + 10}px`,
                  top: `${hoveredPoint.y - 70}px`,
                }}
              >
                <div className="tooltip-price">{formatPrice(hoveredPoint.price)}</div>
                <div className="tooltip-time">{formatTime(hoveredPoint.time)}</div>
                <div className="tooltip-disclaimer">Estimated Price Data</div>
              </div>
            )}
          </>
        )}
      </div>
      
      {/* Data Source Disclaimer */}
      <div className="chart-disclaimer">
        <span className="disclaimer-text">
          üìä Historical price estimates ‚Ä¢ Use "Advanced View" for real-time data
        </span>
      </div>
    </div>
  );
};

export default PriceHistoryChart;