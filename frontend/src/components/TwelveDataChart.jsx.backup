import React, { useEffect, useRef, useState, useCallback } from 'react';
import { useDarkMode } from '../contexts/DarkModeContext';
import './TwelveDataChart.css';

/**
 * Real-Time Price Chart using Solana RPC WebSocket
 * 
 * ‚úÖ FREE - No API keys required
 * ‚úÖ REAL-TIME - Sub-second updates from Solana blockchain
 * ‚úÖ UNIVERSAL - Works for ALL Solana tokens (including meme coins)
 * ‚úÖ RELIABLE - Uses native Solana RPC WebSocket (accountSubscribe)
 * 
 * Instead of polling a REST API or using paid WebSocket services,
 * this monitors the Raydium pool account directly via Solana RPC.
 * Every swap transaction triggers an update, giving true real-time prices.
 */
const TwelveDataChart = ({ coin, isActive = false }) => {
  const { isDarkMode } = useDarkMode();
  const canvasRef = useRef(null);
  const chartDataRef = useRef([]);
  const wsRef = useRef(null);
  const [status, setStatus] = useState('idle');
  const [error, setError] = useState(null);
  const [currentPrice, setCurrentPrice] = useState(null);
  const [priceChange, setPriceChange] = useState(null);
  const mountedRef = useRef(true);
  const initialPriceRef = useRef(null);

  // WebSocket server URL (our backend proxy)
  const WS_URL = import.meta.env.VITE_WS_URL || 'ws://localhost:3001/ws/price';

  // Get token address
  const getTokenAddress = useCallback(() => {
    return coin?.pairAddress || 
           coin?.tokenAddress || 
           coin?.baseToken?.address ||
           coin?.mintAddress ||
           null;
  }, [coin]);


  // Cleanup function
  const cleanup = useCallback(() => {
    console.log('üßπ Birdeye: Cleaning up');
    
    // Close WebSocket connection
    if (wsRef.current) {
      console.log('üßπ Birdeye: Closing WebSocket');
      try {
        wsRef.current.close();
      } catch (err) {
        console.error('Error closing WebSocket:', err);
      }
      wsRef.current = null;
    }

    // Clear canvas
    if (canvasRef.current) {
      const ctx = canvasRef.current.getContext('2d');
      if (ctx) {
        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
      }
    }
    
    // Reset refs
    chartDataRef.current = [];
    initialPriceRef.current = null;
  }, []);

  // Draw chart on canvas
  const drawChart = useCallback(() => {
    if (!canvasRef.current || chartDataRef.current.length === 0) {
      return;
    }

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Set canvas size to match container
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

    const width = rect.width;
    const height = rect.height;
    const padding = { top: 20, right: 50, bottom: 40, left: 60 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Background
    ctx.fillStyle = isDarkMode ? '#1a1a1a' : '#ffffff';
    ctx.fillRect(0, 0, width, height);

    const data = chartDataRef.current;
    if (data.length < 2) return;

    // Calculate min/max
    const prices = data.map(d => d.value);
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const priceRange = maxPrice - minPrice || maxPrice * 0.01;

    // Draw grid lines
    ctx.strokeStyle = isDarkMode ? '#2a2e39' : '#e1e3e8';
    ctx.lineWidth = 1;
    
    for (let i = 0; i <= 4; i++) {
      const y = padding.top + (chartHeight / 4) * i;
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(width - padding.right, y);
      ctx.stroke();
    }

    // Draw area chart
    ctx.beginPath();
    ctx.moveTo(padding.left, height - padding.bottom);

    data.forEach((point, i) => {
      const x = padding.left + (i / (data.length - 1)) * chartWidth;
      const normalizedValue = (point.value - minPrice) / priceRange;
      const y = padding.top + chartHeight * (1 - normalizedValue);
      ctx.lineTo(x, y);
    });

    ctx.lineTo(width - padding.right, height - padding.bottom);
    ctx.closePath();

    // Gradient fill
    const gradient = ctx.createLinearGradient(0, padding.top, 0, height - padding.bottom);
    const isPositive = priceChange !== null ? priceChange >= 0 : true;
    if (isPositive) {
      gradient.addColorStop(0, isDarkMode ? 'rgba(16, 185, 129, 0.4)' : 'rgba(16, 185, 129, 0.3)');
      gradient.addColorStop(1, isDarkMode ? 'rgba(16, 185, 129, 0.05)' : 'rgba(16, 185, 129, 0.1)');
    } else {
      gradient.addColorStop(0, isDarkMode ? 'rgba(239, 68, 68, 0.4)' : 'rgba(239, 68, 68, 0.3)');
      gradient.addColorStop(1, isDarkMode ? 'rgba(239, 68, 68, 0.05)' : 'rgba(239, 68, 68, 0.1)');
    }
    ctx.fillStyle = gradient;
    ctx.fill();

    // Draw line
    ctx.beginPath();
    data.forEach((point, i) => {
      const x = padding.left + (i / (data.length - 1)) * chartWidth;
      const normalizedValue = (point.value - minPrice) / priceRange;
      const y = padding.top + chartHeight * (1 - normalizedValue);
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    ctx.strokeStyle = isPositive ? '#10b981' : '#ef4444';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Draw Y-axis labels
    ctx.fillStyle = isDarkMode ? '#d1d4dc' : '#191919';
    ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.textAlign = 'right';
    
    for (let i = 0; i <= 4; i++) {
      const price = minPrice + (priceRange / 4) * (4 - i);
      const y = padding.top + (chartHeight / 4) * i;
      let priceText;
      if (price < 0.000001) priceText = price.toExponential(2);
      else if (price < 0.001) priceText = price.toFixed(6);
      else if (price < 1) priceText = price.toFixed(4);
      else if (price < 100) priceText = price.toFixed(2);
      else priceText = price.toFixed(0);
      
      ctx.fillText(`$${priceText}`, padding.left - 5, y + 4);
    }

    // Draw X-axis labels (time)
    ctx.textAlign = 'center';
    const timeLabels = [0, Math.floor(data.length / 2), data.length - 1];
    timeLabels.forEach(i => {
      if (data[i]) {
        const x = padding.left + (i / (data.length - 1)) * chartWidth;
        const date = new Date(data[i].time * 1000);
        const timeText = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        ctx.fillText(timeText, x, height - padding.bottom + 20);
      }
    });
  }, [isDarkMode, priceChange]);

  // Connect to WebSocket
  const connectWebSocket = useCallback(() => {
    const tokenAddress = getTokenAddress();
    if (!tokenAddress) {
      setError('No token address found');
      setStatus('error');
      return;
    }

    try {
      console.log('üì° Connecting to price WebSocket server...');
      setStatus('connecting');
      setError(null);

      const ws = new WebSocket(WS_URL);
      wsRef.current = ws;

      ws.onopen = () => {
        console.log('‚úÖ Connected to price WebSocket server');
        setStatus('connected');
        
        // Subscribe to token price updates
        console.log(`üìä Subscribing to price updates for ${tokenAddress}`);
        ws.send(JSON.stringify({
          type: 'subscribe',
          token: tokenAddress
        }));
      };

      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          
          switch (message.type) {
            case 'connected':
              console.log('‚úÖ WebSocket handshake complete');
              break;

            case 'subscribed':
              console.log(`‚úÖ Subscribed to ${message.token}`);
              setStatus('subscribed');
              break;

            case 'price_update':
              handlePriceUpdate(message.data);
              break;

            case 'error':
              console.error('‚ùå WebSocket error:', message.message);
              setError(message.message);
              setStatus('error');
              break;

            case 'pong':
              // Heartbeat response
              break;

            default:
              console.warn('Unknown message type:', message.type);
          }
        } catch (err) {
          console.error('Error parsing WebSocket message:', err);
        }
      };

      ws.onerror = (event) => {
        console.error('‚ùå WebSocket connection error:', event);
        setError('WebSocket connection failed');
        setStatus('error');
      };

      ws.onclose = (event) => {
        console.log(`üîå WebSocket closed (code: ${event.code})`);
        setStatus('disconnected');
        
        // Auto-reconnect if component is still mounted
        if (mountedRef.current && isActive) {
          console.log('üîÑ Reconnecting in 3 seconds...');
          setTimeout(() => {
            if (mountedRef.current && isActive) {
              connectWebSocket();
            }
          }, 3000);
        }
      };

    } catch (err) {
      console.error('Error connecting to WebSocket:', err);
      setError(err.message);
      setStatus('error');
    }
  }, [getTokenAddress, isActive, WS_URL]);

  // Handle incoming price updates
  const handlePriceUpdate = useCallback((data) => {
    if (!mountedRef.current) return;

    const { price, timestamp } = data;
    
    // Set initial price for % change calculation
    if (initialPriceRef.current === null) {
      initialPriceRef.current = price;
    }

    // Update current price
    setCurrentPrice(price);

    // Calculate price change
    const change = ((price - initialPriceRef.current) / initialPriceRef.current) * 100;
    setPriceChange(change);

    // Add to chart data
    const dataPoint = {
      timestamp,
      time: Math.floor(timestamp / 1000),
      price,
      value: price
    };

    chartDataRef.current.push(dataPoint);

    // Keep only last 100 data points (or adjust as needed)
    if (chartDataRef.current.length > 100) {
      chartDataRef.current.shift();
    }

    // Redraw chart
    drawChart();
  }, [drawChart]);

    console.log(`üîå Birdeye: Connecting to proxy for token ${tokenAddress}`);
    setStatus('loading');
    setError(null);

    try {
      // Connect to backend proxy instead of directly to Birdeye
      // The proxy handles the required headers that browsers can't set
      const ws = new WebSocket(BIRDEYE_PROXY_URL);
      wsRef.current = ws;

      ws.onopen = () => {
        console.log(`‚úÖ Birdeye: Connected to backend proxy`);
        
        // Subscribe to price updates for this token
        // Backend proxy will forward this to Birdeye with proper headers
        const subscribeMessage = {
          type: 'SUBSCRIBE_PRICE',
          data: {
            chartType: '1m', // 1-minute OHLCV candles
            currency: 'pair', // Token pair data
            address: tokenAddress // Token pair address
          }
        };
        
        console.log('üì§ Birdeye: Subscribing to price updates:', subscribeMessage);
        ws.send(JSON.stringify(subscribeMessage));
      };

      ws.onmessage = (event) => {
        if (!mountedRef.current) return;

        try {
          const data = JSON.parse(event.data);
          console.log('üì® Birdeye: Message received:', data);

          // Handle error responses
          if (data.type === 'ERROR') {
            console.error('‚ùå Birdeye API Error:', data);
            if (mountedRef.current) {
              setStatus('error');
              setError(`API Error: ${data.data || 'Origin/API key issue'}`);
            }
            return;
          }

          // Handle welcome message
          if (data.type === 'WELCOME') {
            console.log('üëã Birdeye: Welcome message received');
            return;
          }

          // Handle subscription confirmation
          if (data.type === 'PRICE_DATA' || data.type === 'SUBSCRIBED') {
            setStatus('connected');
            setError(null);
          }

          // Handle price update - THIS IS THE REAL-TIME DATA!
          if (data.type === 'PRICE_DATA' && data.data) {
            const priceData = data.data;
            const price = parseFloat(priceData.value || priceData.price || priceData.o);
            
            if (!price || isNaN(price)) {
              console.log('‚ö†Ô∏è Birdeye: Invalid price data:', priceData);
              return;
            }

            const timestamp = priceData.unixTime || Math.floor(Date.now() / 1000);

            console.log(`üí∞ Birdeye: ‚ö° REAL-TIME PRICE: $${price}`);
            
            // Set initial price for change calculation
            if (initialPriceRef.current === null) {
              initialPriceRef.current = price;
              console.log(`üìç Birdeye: Initial price set: $${price}`);
            }

            // Calculate price change from initial
            const changePercent = ((price - initialPriceRef.current) / initialPriceRef.current) * 100;
            
            setCurrentPrice(price);
            setPriceChange(changePercent);
            setStatus('connected');

            // Add to chart data
            chartDataRef.current = [
              ...chartDataRef.current,
              { time: timestamp, value: price }
            ];

            // Keep last 360 points (about 30 minutes of real-time data)
            if (chartDataRef.current.length > 360) {
              chartDataRef.current = chartDataRef.current.slice(-360);
              // Update initial price reference to oldest point
              initialPriceRef.current = chartDataRef.current[0].value;
            }

            console.log(`üìà Birdeye: Chart now has ${chartDataRef.current.length} points`);

            // Redraw chart
            requestAnimationFrame(() => {
              if (mountedRef.current) {
                drawChart();
              }
            });
          }

          // Handle pong
          if (data.type === 'PONG') {
            console.log('üíì Birdeye: Pong received');
          }

        } catch (err) {
          console.error('‚ùå Birdeye: Error parsing message:', err);
        }
      };

      ws.onerror = (error) => {
        console.error('‚ùå Birdeye: WebSocket error:', error);
        if (mountedRef.current) {
          setStatus('error');
          setError('Connection error');
        }
      };

      ws.onclose = (event) => {
        console.log('üîå Birdeye: WebSocket closed:', event.code, event.reason);
        if (mountedRef.current && status !== 'idle') {
          setStatus('error');
          setError('Connection closed');
        }
        wsRef.current = null;
      };

    } catch (err) {
      console.error('‚ùå Birdeye: Failed to create WebSocket:', err);
      if (mountedRef.current) {
        setStatus('error');
        setError('Failed to connect');
      }
    }
  }, [status, drawChart]);

  // Format price for display
  const formatPrice = (price) => {
    if (!price) return '$0.00';
    if (price < 0.000001) return `$${price.toExponential(2)}`;
    if (price < 0.001) return `$${price.toFixed(6)}`;
    if (price < 1) return `$${price.toFixed(4)}`;
    if (price < 100) return `$${price.toFixed(2)}`;
    return `$${price.toFixed(0)}`;
  };

  // Main initialization effect
  useEffect(() => {
    console.log(`üîÑ Birdeye: Effect triggered - isActive: ${isActive}, coin: ${coin?.symbol}`);
    
    if (!isActive) {
      console.log('‚è∏Ô∏è  Birdeye: Not active, cleaning up');
      cleanup();
      return;
    }

    mountedRef.current = true;

    // Get token address
    const tokenAddress = getTokenAddress();
    
    if (!tokenAddress) {
      console.log(`‚ùå Birdeye: No token address found for ${coin?.symbol}`);
      setStatus('error');
      setError('Token address not found');
      return;
    }

    console.log(`üöÄ Birdeye: Initializing for token: ${tokenAddress}`);
    
    // Connect WebSocket
    connectWebSocket(tokenAddress);

    return () => {
      console.log('üßπ Birdeye: Cleanup from effect');
      mountedRef.current = false;
      cleanup();
    };
  }, [isActive, coin, getTokenAddress, connectWebSocket, cleanup]);

  // Redraw chart when theme changes
  useEffect(() => {
    if (chartDataRef.current.length > 0 && canvasRef.current) {
      requestAnimationFrame(() => {
        if (mountedRef.current) {
          drawChart();
        }
      });
    }
  }, [isDarkMode, drawChart]);

  return (
    <div className="twelve-data-chart">
      {/* Price Header */}
      <div className="twelve-chart-header">
        <div className="price-info">
          <div className="token-symbol">{coin?.symbol || 'Unknown'}</div>
          <div className="current-price">
            {currentPrice ? formatPrice(currentPrice) : '‚Äî'}
          </div>
          {priceChange !== null && (
            <div className={`price-change ${priceChange >= 0 ? 'positive' : 'negative'}`}>
              {priceChange >= 0 ? '+' : ''}{priceChange.toFixed(2)}%
              <span className="timeframe">since start</span>
            </div>
          )}
        </div>
        <div className="chart-info">
          {status === 'connected' && (
            <>
              <span className="live-indicator">‚ö° LIVE</span>
              <span className="update-text">Real-time Birdeye</span>
            </>
          )}
          {status === 'loading' && (
            <span className="update-text">Connecting...</span>
          )}
        </div>
      </div>

      {/* Chart Canvas */}
      <div className="twelve-chart-container">
        <canvas
          ref={canvasRef}
          className="twelve-chart-canvas"
          style={{ width: '100%', height: '100%' }}
        />

        {/* Loading Overlay */}
        {status === 'loading' && (
          <div className="twelve-chart-overlay">
            <div className="twelve-chart-spinner"></div>
            <div className="twelve-chart-message">Connecting to Birdeye WebSocket...</div>
            <div className="twelve-chart-submessage">Real-time price streaming for {coin?.symbol}</div>
          </div>
        )}

        {/* Error Overlay */}
        {status === 'error' && error && (
          <div className="twelve-chart-overlay error">
            <div className="twelve-chart-error-icon">‚ö†Ô∏è</div>
            <div className="twelve-chart-error-title">Connection Error</div>
            <div className="twelve-chart-error-message">{error}</div>
            <div style={{ marginTop: '12px', fontSize: '12px', opacity: 0.8 }}>
              Try refreshing or check back in a moment
            </div>
          </div>
        )}
      </div>

      {/* Info Footer */}
      {status === 'connected' && (
        <div style={{
          padding: '8px 12px',
          fontSize: '11px',
          color: isDarkMode ? '#888' : '#666',
          borderTop: isDarkMode ? '1px solid #2a2e39' : '1px solid #e1e3e8',
          textAlign: 'center'
        }}>
          ‚ö° Birdeye WebSocket connected ‚Ä¢ Real-time updates for {coin?.symbol} ‚Ä¢ No API rate limits
        </div>
      )}
    </div>
  );
};

export default TwelveDataChart;
